{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introducci\u00f3n","text":"<p> En este espacio se presentan algunos apuntes del m\u00f3dulo de Sistemas en Big Data en el Curso de espacializaci\u00f3n de Isnteligencia Artificial y Big Data que se imparte en el I.E.S. Lluis Simarro de X\u00e0tiva. </p> <ul> <li>Elaboraci\u00f3n: Alberto Aparicio Vila </li> </ul> <p>Dpto. Inform\u00e1tica I.E.S. Dr. Llu\u00eds Simarro Lacabra X\u00e0tiva</p> <p>Fuentes utilizadas</p> <ul> <li>Aitor Medrano. Cursos Inteligencia Artificial y Big Data. Almacen de datos NoSQL</li> <li>Next Generation Databases: NoSQL, NewSQL, and Big Data</li> <li>NoSQL Distilled: A Brief Guide to the Emerging World of Polyglot Persistence</li> <li>Row vs Column Oriented Databases</li> <li>Understanding Database Sharding</li> </ul>"},{"location":"mongodb/basicsmongo/","title":"Primeros pasos","text":"<p>Una vez instalada la base de datos, vamos a interactuar desde su propia consola.</p>"},{"location":"mongodb/basicsmongo/#trabajando-con-mongodb-desde-la-consola","title":"Trabajando con MongoDB desde la consola","text":"<p>En la m\u00e1quina donde tenemos instalada la base de datos, podemos acceder a la consola de MongoDB escribimos:</p> <pre><code>mongosh\n</code></pre> Acceso a trav\u00e9s de la consola <p>Vemos que cuando accedemos a trav\u00e9s de la consola, nos aparece una serie de recomendaciones que debemos realizar antes de comenzar a trabajar con MongoDB:</p> <ul> <li>Sistema de archivos XFS recomendado</li> <li>No hay control de acceso habilitado</li> <li>Aumentar la cantidad de mapeos de memoria virtual</li> <li>Swappiness</li> </ul>"},{"location":"mongodb/basicsmongo/#activar-autenticacion-para-mongodb","title":"Activar autenticaci\u00f3n para MongoDB","text":"<ol> <li>Creamos el usuario a trav\u00e9s de la consola de MongoDB: <pre><code>use admin\ndb.createUser({\n  user: \"admin\",\n  pwd: \"password_fuerte\",\n  roles: [ { role: \"root\", db: \"admin\" } ]\n})\n</code></pre></li> <li>Editamos el archivo de configuraci\u00f3n <code>/etc/mongod.conf</code> y agregamos: <pre><code>security:\n  authorization: enabled\n</code></pre></li> <li>Reiniciamos el servicio <pre><code>sudo systemctl restart mongod\n</code></pre></li> </ol>"},{"location":"mongodb/basicsmongo/#aumentar-los-mapeos","title":"Aumentar los mapeos","text":"<ol> <li>Consultamos los mapeos que tenemos actualmente: <pre><code>cat /proc/sys/vm/max_map_count\n</code></pre></li> <li>Cambiamos el valor temporalmente <pre><code>sudo sysctl -w vm.max_map_count=1048575\n</code></pre></li> <li>Para hacerlo permanentemente: <pre><code>echo \"vm.max_map_count=1048575\" | sudo tee -a /etc/sysctl.conf\nsudo sysctl -p\n</code></pre></li> </ol>"},{"location":"mongodb/basicsmongo/#swappiness","title":"Swappiness","text":"<ol> <li>Consultamos el valor actual: <pre><code>cat /proc/sys/vm/swappiness\n</code></pre></li> <li>Cambiamos el valor temporalmente: <pre><code>sudo sysctl -w vm.swappiness=1\n</code></pre></li> <li>Para hacerlo temporalmente: <pre><code>echo \"vm.swappiness=1\" | sudo tee -a /etc/sysctl.conf\nsudo sysctl -p\n</code></pre></li> </ol>"},{"location":"mongodb/basicsmongo/#operaciones-basicas","title":"Operaciones b\u00e1sicas","text":"<p>Conectamos desde la consola con un usuario: <pre><code>mongosh -u admin -p 'PasswordSegura' --authenticationDatabase admin\n</code></pre></p> <p>Algunas de las operaciones b\u00e1sicas que podemos realizar son :</p> <ul> <li>Salir de la consola (<code>quit()</code> o pulsando <code>Ctrl+C</code>)</li> <li>Limpiar la consola (<code>Ctrl+L</code>)</li> <li>Listar las bases de datos (<code>show dbs</code>)</li> <li>Cambiarse de base de datos (<code>use &lt;dbname&gt;</code>)</li> <li>Listar las colecciones de una base de datos (<code>show collections</code> / <code>show tables</code>)</li> <li>Mostrar el nombre de la base de datos (<code>db.getName()</code> o <code>db</code>)</li> <li>Listar metadata sobre una base de datos (<code>db.stats()</code>)</li> <li>Solicitar ayuda sobre comandos (<code>db.help()</code>)</li> <li>Mostrar fecha y hora del sistema (<code>Date()</code>)</li> <li>Dar formato JSON (<code>db.&lt;collectionName&gt;.find().pretty()</code>)</li> <li>Mostrar informaci\u00f3n sobre el servidor (<code>db.hostInfo()</code>)</li> </ul> <p>Info</p> <p>db.hostInfo: Este es un atributo que hace referencia a la informaci\u00f3n del sistema, pero no ejecuta la funci\u00f3n. Al usarlo de esta manera, no se obtienen datos directamente; simplemente se esta accediendo a una propiedad.</p> <p>db.hostInfo(): Este es un m\u00e9todo que, al ser llamado con par\u00e9ntesis, ejecuta la funci\u00f3n y devuelve un documento con informaci\u00f3n detallada sobre el sistema subyacente en el que se est\u00e1 ejecutando el servidor MongoDB. En este caso se incluyen datos como el nombre del host, la arquitectura de la CPU, la memoria disponible, entre otros</p>"},{"location":"mongodb/basicsmongo/#creacion-y-gestion-de-bases-de-datos","title":"Creaci\u00f3n y gesti\u00f3n de Bases de Datos","text":""},{"location":"mongodb/basicsmongo/#creacion-use","title":"Creaci\u00f3n: <code>use</code>","text":"<p>El comando para crear una base de datos es el mismo que visto anteriormente para cambiar de base de datos: <code>use</code></p> <p>As\u00ed pues si intentamos entrar/acceder en una base de datos que no existe, hasta que no se inserte al menos un documento en una de sus colecciones, no estar\u00e1 disponible. Esto lo podemos hacer en el siguiente ejemplo:</p> <pre><code>use prueba\nshow dbs\ndb.primeraColeccion.insertOne({ id: 1, nombre: 'Alberto'})\n</code></pre> <p>Todo esto es debido a que MongoDB planifica la existencia de una base de datos, pero hasta que no tenga su primer dato, no va a designar ning\u00fan tipo de recursos a la misma. En la captura anterior, se ve que ya le ha asignado 8 KiB a nuestra primera base de datos porque ya tiene alg\u00fan dato.</p> <p>Por otra parte, para la creaci\u00f3n de una colecci\u00f3n e inclusi\u00f3n de un documento en concreto, observar que simplemente al insertar el documento, si la colecci\u00f3n no existe, la crea directamente, de la misma forma que ha hecho con la base de datos.</p> <p>M\u00e1s adelante ya veremos con m\u00e1s detenimiento las diferentes forma de insertar registro en un tabla (colecci\u00f3n), de momento hemos usando el comando: <pre><code>db.primeraColeccion.insertOne({ id: 1, nombre: 'Alberto'})\n</code></pre></p>"},{"location":"mongodb/basicsmongo/#eliminacion-dbdropdatabase","title":"Eliminaci\u00f3n: <code>db.dropDatabase()</code>","text":"<p>Para eliminar una base de datos, en primer lugar debemos estar ubicados dentro de la propia base de datos a eliminar y ah\u00ed ejecutamos el comando:</p> <pre><code>db.dropDatabase()\n</code></pre> <p>Podemos hacer uso de los comandos use y db para pasar ubicarnos en una base de datos y comprobar que efectivamente lo estamos, aunque en el prompt de la propia shell de MongoDB directamente ya nos dice que estamos ah\u00ed:</p>"},{"location":"mongodb/basicsmongo/#mongodb-database-tools","title":"MongoDB Database Tools","text":"<p>Adem\u00e1s del propio servidor de MongoDB y el cliente para conectarse a \u00e9l, MongoDB ofrece un conjunto de herramientas para interactuar con las bases de datos, permitiendo crear y restaurar copias de seguridad.</p> <p>Si estamos interesados en introducir o exportar una colecci\u00f3n de datos mediante JSON, podemos emplear los comandos <code>mongoimport</code> y <code>mongoexport</code>:</p> <pre><code>mongoimport -d nombreBaseDatos -c coleccion \u2013-file nombreFichero.json\nmongoexport -d nombreBaseDatos -c coleccion nombreFichero.json\n</code></pre> <p>Estas herramientas interact\u00faan con datos JSON y no sobre toda la base de datos.</p> <p>Note</p> <p>Estos comandos se ejecutan desde la shell donde tenemos instalados MongoDB, no desde la propia shell de MongoDB</p> <p>Un caso particular y muy com\u00fan es importar datos que se encuentran en formato CSV/TSV. Para ello, emplearemos el par\u00e1metro <code>--type csv</code>. Por ejemplo, podemos descargar el fichero personas.csv e importarlo en la bd test:</p> <pre><code>mongoimport --username admin --password \"simarro2025.\" --authenticationDatabase admin --type csv --db test --collection personas --headerline --file personas.csv\n</code></pre> <p>Donde - <code>--type</code> : indica el tipo de fichero; csv o tsv - <code>-d</code> o <code>--db</code>: indica la base de datos - <code>-c</code> o <code>--collection</code> : indica la colecci\u00f3n - <code>--headerline</code>: en un csv o tsv indica que la primera l\u00ednea contiene los nombres de los campos</p> <p>Mas informaci\u00f3n en el Manual de MongoDB: mongoimport</p> <p>En lugar de realizar un export, es m\u00e1s conveniente realizar un backup en binario mediante <code>mongodump</code>, el cual genera ficheros BSON. Estos archivos posteriormente se restauran mediante <code>mongorestore</code>:</p> <pre><code>mongodump -d nombreBaseDatos nombreFichero.bson\nmongorestore -d nombreBaseDatos nombreFichero.bson\n</code></pre> <p>Si necesitamos transformar un fichero BSON a JSON (de binario a texto), tenemos el comando <code>bsondump</code>:</p> <p><pre><code>bsondump file.bson &gt; file.json\n</code></pre> M\u00e1s informaci\u00f3n sobre copias de seguridad en la documentaci\u00f3n oficial de MongoDB: MongoDB Backup Methods.</p> <p>Para poder trabajar con MongoDB desde cualquier aplicaci\u00f3n necesitamos un driver. MongoDB ofrece drivers oficiales para casi todos los lenguajes de programaci\u00f3n actuales. En una sesi\u00f3n posterior trabajaremos con <code>pyMongo</code>.</p> <p>En cuanto a la monitorizaci\u00f3n, tanto <code>mongostat</code> como <code>mongotop</code> permiten visualizar el estado del servidor MongoDB, as\u00ed como algunas estad\u00edsticas sobre su rendimiento. Si trabajamos con MongoAtlas estas herramientas est\u00e1n integradas en las diferentes herramientas de monitorizaci\u00f3n de la plataforma.</p>"},{"location":"mongodb/basicsmongo/#tipos-de-datos","title":"Tipos de datos","text":"<p>Aqu\u00ed tienes una lista de algunos tipos de datos comunes en MongoDB, junto con ejemplos de c\u00f3mo se representan en formato de tabla:</p> Tipo de Datos Descripci\u00f3n Ejemplo String Cadena de texto \"Hello World\" Number N\u00famero 42 Boolean Valor booleano (true/false) true Date Fecha y hora ISODate(\"2024-03-01T12:00:00.000Z\") Array Array de valores [1, 2, 3] Object Objeto o documento anidado {\"nombre\": \"Juan\", \"edad\": 30} ObjectId Identificador \u00fanico de documento ObjectId(\"61e4c3055b17967d02a9c3d7\") Null Valor nulo null BinData Datos binarios BinData(0, \"ABC123==\") Regular Expressions Expresiones regulares /pattern/g <p>Recuerda que MongoDB es una base de datos NoSQL orientada a documentos, por lo que no tiene una estructura de tabla como las bases de datos relacionales. En MongoDB, los datos se almacenan en documentos BSON (Binary JSON), que pueden contener campos con diferentes tipos de datos, incluidos los mencionados anteriormente.</p> <p>Es importante destacar que en MongoDB, los datos binarios y las expresiones regulares se representan de manera especial. Los datos binarios se representan mediante el tipo <code>BinData</code>, que incluye un tipo y una cadena de datos codificados en <code>base64</code>.</p> <p>Las expresiones regulares se representan utilizando el formato <code>/pattern/flags</code>, donde <code>pattern</code> es el patr\u00f3n de la expresi\u00f3n regular y <code>flags</code> son los modificadores de la expresi\u00f3n regular, como <code>i</code> para ignorar may\u00fasculas y min\u00fasculas o <code>g</code> para realizar una b\u00fasqueda global.</p> <p>El formato <code>/pattern/flags</code></p> <p>se utiliza com\u00fanmente en expresiones regulares (regex) en varios lenguajes de programaci\u00f3n, incluyendo JavaScript y MongoDB. Aqu\u00ed te explico cada parte:</p> <p><code>/pattern/</code>: Esta parte define el patr\u00f3n que deseas buscar. El patr\u00f3n puede incluir caracteres literales, metacaracteres y secuencias de escape. Por ejemplo, /abc/ buscar\u00eda la secuencia \u201cabc\u201d.</p> <p><code>flags</code>: Los flags son modificadores que alteran el comportamiento de la b\u00fasqueda. Algunos de los flags m\u00e1s comunes son:</p> <ul> <li><code>i</code>: Ignora may\u00fasculas y min\u00fasculas (case insensitive).        </li> <li><code>g</code>: Realiza una b\u00fasqueda global, es decir, encuentra todas las coincidencias en lugar de detenerse en la primera.</li> <li><code>m</code>: Permite que el car\u00e1cter ^ y $ coincidan con el inicio y el final de cada l\u00ednea, no solo del texto completo.</li> </ul> <p>Ejemplo:</p> <ul> <li>Si quisieras buscar la palabra <code>\u201chola\u201d</code> sin importar si est\u00e1 en may\u00fasculas o min\u00fasculas en un texto, usar\u00edas <code>/hola/i</code>.</li> </ul> <p>Mas info en MongoDb docs $regex</p> <p>Aqu\u00ed tienes un ejemplo de c\u00f3mo se podr\u00eda representar un documento en MongoDB utilizando algunos de estos tipos de datos:</p> <pre><code>{\n  \"_id\": ObjectId(\"61e4c3055b17967d02a9c3d7\"),\n  \"nombre\": \"Juan\",\n  \"edad\": 30,\n  \"activo\": true,\n  \"intereses\": [\"programaci\u00f3n\", \"m\u00fasica\", \"viajes\"],\n  \"ubicacion\": {\n    \"ciudad\": \"Barcelona\",\n    \"pais\": \"Espa\u00f1a\"\n  },\n  \"fechaRegistro\": ISODate(\"2025-03-01T12:00:00.000Z\"),\n  \"comentarios\": [\n    {\n      \"usuario\": \"Ana\",\n      \"texto\": \"\u00a1Hola Juan!\"\n    },\n    {\n      \"usuario\": \"Carlos\",\n      \"texto\": \"Saludos desde X\u00e0tiva.\"\n    }\n  ]\n}\n</code></pre> Tipos de datos en MongoDB <p>En este ejemplo, que ya hemos visto previamente para ilustrar qu\u00e9 es un BSON, el documento representa un usuario con campos como nombre, edad, activo, intereses, ubicaci\u00f3n, fecha de registro y comentarios. Cada campo tiene un tipo de datos diferente, como string, number, boolean, array, object, date, etc.</p> <p>M\u00e1s informaci\u00f3n sobre tipos de datos en MongoDB - Datatypes</p>"},{"location":"mongodb/instalacion/","title":"Instalaci\u00f3n","text":""},{"location":"mongodb/instalacion/#instalacion-de-mongodb","title":"Instalaci\u00f3n de MongoDB","text":"<p>En la actualidad, MongoDB se compone de tres productos diferentes m\u00e1s un conglomerado de servicios y herramientas que complementas a la base de datos.</p> Productos MongoDB <ul> <li>Mongo Atlas, como plataforma cloud, con una opci\u00f3n gratuita mediante un cluster de 512MB.</li> <li>MongoDB Enterprise Advanced, versi\u00f3n de pago con soporte, herramientas avanzadas de monitorizaci\u00f3n y seguridad, y administraci\u00f3n automatizada.</li> <li>MongoDB Community Edition, versi\u00f3n gratuita para trabajar on-premise, con versiones para Windows, MacOS y Linux. Nosotros de momento trabajaremos con esta versi\u00f3n.</li> </ul>"},{"location":"mongodb/instalacion/#instalacion-en-sistemas-windows","title":"Instalaci\u00f3n en sistemas Windows","text":"<p>Para instalar MongoDB en un equipo Microsoft Windows:</p> <ul> <li>Vamos a la web de MongoDB en su secci\u00f3n de descargas (versi\u00f3n Community)</li> <li>Descargamos e instalamos.</li> </ul> Instalaci\u00f3n de MongoDB en Windows <p>Nota: Al realizar esta instalaci\u00f3n al mismo tiempo instalamos MongoDB Compass que veremos m\u00e1s adelante. Se trata de una interface de acceso a MongoDB.</p>"},{"location":"mongodb/instalacion/#instalacion-en-debian-12","title":"Instalaci\u00f3n en Debian 12","text":"<p>Para la instalaci\u00f3n de MongoDB Community Edition en un sistema Debian vamos a proceder tal y como se espedifica en la propia web de mongodb. Install MongoDB Community Edition</p> <p>Realizaremos los siguientes pasos:</p> <pre><code># Requisitos previos\nsudo apt-get install gnupg curl                   # Requisitos previos\n\n# Importar claves p\u00fablicas GPG de MongoDB\ncurl -fsSL https://www.mongodb.org/static/pgp/server-8.0.asc | \\\n   sudo gpg -o /usr/share/keyrings/mongodb-server-8.0.gpg \\\n   --dearmor\n\n# a\u00f1adir las fuentes\necho \"deb [ arch=amd64,arm64 signed-by=/usr/share/keyrings/mongodb-server-8.0.gpg ] https://repo.mongodb.org/apt/ubuntu noble/mongodb-org/8.0 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-8.0.list\n\n# recargar paquetes\nsudo apt-get update\n\n# e instalar\nsudo apt-get install -y mongodb-org\n</code></pre> <p>Con esto ya tenemos MongoDB instalado en nuestro sistema.</p> <p>Ahora nos falta ponerlo en marcha, para ello habilitamos e iniciamos el servicio:</p> <pre><code># recargamos los nuevos servicios\nsudo systemctl daemon-reload\n\n# Habilitamos el servicios (esto es opcional, solo si queremos que se inicie al arrancar el equipo)\nsudo systemctl enable mongod\n\n# Iniciamos el servicio\nsudo systemctl start mongod\n\n# Comprobamos que el servicio se ha iniciado correctamente\nsudo systemctl status mongod\n</code></pre> Instalaci\u00f3n MongoDB Debian12 <pre><code>mongod --version                                  # Comprobamos la versi\u00f3n\n</code></pre> Comprobar servicio mongod <p>Nota: MongoDB tambi\u00e9n lo podemos instalar descargando el paquete .deb desde la web de MongoDB, pero suele dar mas problemas que con la instalaci\u00f3n presentada.</p>"},{"location":"mongodb/instalacion/#instalacion-mongodb-en-los-contenedores-de-proxmox-de-clase","title":"Instalaci\u00f3n MongoDB en los Contenedores de Proxmox de clase","text":"<p>Para poder utilizar MongoDB en los contenedores, necesitamos realizar las siguientes acciones.</p> <ul> <li>En primer lugar, es adecuado asignar una IP est\u00e1tica a cada uno de los contenedores, o al menos conocer la IP del contenedor para poder conectar con el.</li> <li>En segundo lugar, instalamos MongoDB siguiendo los mismos pasos indicados anteriormente para su instalaci\u00f3n en Debian12. Podemos referirnos directamente a las indicaciones en la propia web de MongoDB</li> <li>Para finalizar, necesitamos configurar MongoDB para permitir el acceso desde un equipo externo. Esto tambi\u00e9n se debe hacer en la instalaci\u00f3n en Debian si queremos acceder desde otro equipo.</li> </ul> <p>Para ello, editamos el fichero de configuraci\u00f3n <code>/etc/mongod.conf</code></p> <p>Especificamos la IP de nuestro equipo en el apartado correspondiente (net). En el ejemplo siguiente la IP del contenedor o servidor MongoDB es la 10.20.90.150:</p> <p><pre><code># network interfaces\nnet:\n  port: 27017\n  bindIp: 127.0.0.1,10.20.90.150\n</code></pre> Reiniciamos el servicio</p> <pre><code>sudo systemctl restart mongod\n</code></pre>"},{"location":"mongodb/instalacion/#otras-posibles-instalaciones","title":"Otras posibles instalaciones","text":"<p>En vez de instalarlo como un servicio en nuestra m\u00e1quina, a d\u00eda de hoy, es mucho m\u00e1s c\u00f3modo hacer uso de contenedores Docker o utilizar una soluci\u00f3n cloud, aunque nosotros por simplicidad, de momento, realizaremos una instalaci\u00f3n tradicional.</p> <pre><code>docker run --name mongodb -d -p 27017:27017 -v mongodb_data:/data/db mongo\n</code></pre>"},{"location":"mongodb/instalacion/#probando-la-instalacion","title":"Probando la instalaci\u00f3n","text":"<p>Independientemente de nuestro sistema operativo, por defecto, el servicio o demonio (daemon) se lanza sobre el puerto 27017. Una vez instalado, si accedemos a <code>http://localhost:27017</code> podremos ver que nos indica c\u00f3mo estamos intentando acceder mediante HTTP a MongoDB mediante el puerto reservado al driver nativo.</p> Accediendo a MongoDB"},{"location":"mongodb/instalacion/#mongo-atlas","title":"Mongo Atlas","text":"<p>Si por el motivo que sea no deseamos instalar MongoDB, si no que queremos utilizar su versi\u00f3n cloud, tenemos Mongo Atlas:</p> MongoDB Atlas <p>La versi\u00f3n de Mongo Atlas nos ofrece de manera gratuita un cluster compartido de servidores con 3 nodos y 512 MB para datos. Si queremos una soluci\u00f3n serverless o un servidor dedicado, ya tendremos que pasar por caja.</p> <p>Obviamente para hacer uso de esta versi\u00f3n, necesitas registrarte en la web de MongoDB.</p>"},{"location":"mongodb/instalacion/#herramientas-visuales-para-interactuar-con-mongodb","title":"Herramientas visuales para interactuar con MongoDB","text":"<p>Podemos interactuar con MongoDB con su propia consola MongoDB shell, que nos ofrece la base de datos, , m\u00e1s adelante veremos c\u00f3mo podemos hacerlo, pero para interactuar de una forma m\u00e1s flexible e intuitiva existen herramientas visuales que nos facilitan el trabajo diario con MongoDB.</p>"},{"location":"mongodb/instalacion/#mongodb-compass","title":"MongoDB Compass","text":"<p>Una de ellas es MongoDB Compass, que facilita la exploraci\u00f3n y manipulaci\u00f3n de los datos. De una manera flexible e intuitiva, Compass ofrece visualizaciones detalladas de los esquemas, m\u00e9tricas de rendimiento en tiempo real as\u00ed como herramientas para la creaci\u00f3n de consultas.</p> <p>Existen tres versiones de Compass, una completa con todas las caracter\u00edsticas, una de s\u00f3lo lectura sin posibilidad de insertar, modificar o eliminar datos (perfecta para anal\u00edtica de datos) y una \u00faltima versi\u00f3n isolated que solo permite la conexi\u00f3n a una instancia local.</p> <p>Enlace a la documentaci\u00f3n oficial de MongoDB Compass: What is MongoDB Compass?</p>"},{"location":"mongodb/instalacion/#instalacion_1","title":"Instalaci\u00f3n","text":"<p>Siguiendo los pasos ofrecidos por la propia web de MongoDB, para la instalaci\u00f3n de MongoDB Compass en Debian seguimos los siguientes pasos:</p> <pre><code># Download MongoDB Compass\nwget https://downloads.mongodb.com/compass/mongodb-compass_1.46.6_amd64.deb\n\n# Install MongoDB Compass\nsudo apt install ./mongodb-compass_1.46.6_amd64.deb\n\n# Start *MongoDB* Compass\nmongodb-compass\n</code></pre> <p>Si hacemos caso a lo que nos dicen en la gu\u00eda de instalaci\u00f3n proporcionada por MongoDB, directamente instalamos la \u00faltima versi\u00f3n estable.</p> MongoDB Compass"},{"location":"mongodb/instalacion/#trabajando-con-mongodb-compass","title":"Trabajando con MongoDB Compass","text":"<p>Al iniciar la aplicaci\u00f3n, la primera vez nos ofrece conectarnos a la base de datos local. Tambi\u00e9n nos podemos conectar a una base de datos remota e incluso a Mongo Atlas, que como se coment\u00f3 es la base de datos que ofrece MongoDB en la nube.</p> <p>Una vez conectados a la base de datos, vemos todas las bases de datos exitentes. En la parte inferior tenemos una consola donde podemos actuar de la misma forma que lo hicimos anteriormente.</p> MongoDB Compass <p>Dentro de una base de datos, podemos acceder a las colecciones, listar los documentos, y realizar todo tipo de operaciones sobre los mismos:</p> MongoDB Compass - Colecciones <p>As\u00ed como operaciones espec\u00edficas sobre documentos en concreto. Si nos colocamos con el rat\u00f3n sobre un documento aparecen cuatro opciones, para editar, copiar, duplicar y borrar el documento. Haciendo doble click, tambi\u00e9n lo editamos.</p> <p>Tenemos varias opciones sobre la base de datos, incluso podemos hacer consultas.</p> MongoDB Compass - Edici\u00f3n"},{"location":"mongodb/instalacion/#mongodb-for-vscode","title":"MongoDB for VSCode","text":"<p>Tambi\u00e9n podemos utilizar la extensi\u00f3n que lleva VSCode para trabajar con MongoDB. Una vez instalado VSCode, instalamos la extensi\u00f3n de MongoDB for VS Code, Aqu\u00ed seguimos los pasos de la web oficial donde tenemos c\u00f3mo instalar y configurar la conexi\u00f3n: VSCode: Working with MongoDB. Para la conexi\u00f3n, pulsamos sobre el bot\u00f3n de Advanced y la conexi\u00f3n es sencilla:</p> Extensi\u00f3n MongoDB en VSCode MongoDB con VSCode <p>Realmente, esta extensi\u00f3n este pensada para trabajar con opciones avanzadas, como crear \u00edndices, generar c\u00f3digo en lenguajes como javascript, python o cualquier otro para realizar todo tipo de operaciones en MongoDB, o crear variables con datos y estos utilizarlos en nuestras operaciones. Para m\u00e1s informaci\u00f3n en la web de la extension: MongoDB for VS Code. MongoDB Without Leaving Your IDE</p>"},{"location":"mongodb/intromongo/","title":"MongoDB","text":""},{"location":"mongodb/intromongo/#introduccion-a-mongodb","title":"Introducci\u00f3n a MongoDB","text":"<p>En el mundo del Big Data, donde la cantidad de datos generados y procesados contin\u00faa creciendo exponencialmente, la elecci\u00f3n de la tecnolog\u00eda adecuada para almacenar, gestionar y analizar estos datos es fundamental. MongoDB, una base de datos NoSQL de c\u00f3digo abierto y orientada a documentos, ha emergido como una soluci\u00f3n poderosa y vers\u00e1til en este panorama en constante evoluci\u00f3n.</p> <p>!!! note \"As\u00ed fue c\u00f3mo naci\u00f3 MongoDB     MongoDB fue fundada en 2007 por Dwight Merriman, Eliot Horowitz y Kevin Ryan, el equipo detr\u00e1s de DoubleClick.     En la empresa de publicidad en Internet DoubleClick (ahora propiedad de Google), el equipo desarroll\u00f3 y utiliz\u00f3 numerosos almacenes de datos personalizados para solucionar las carencias de las bases de datos existentes. El negocio serv\u00eda 400 000 anuncios por segundo, pero a menudo ten\u00eda problemas de escalabilidad y agilidad. Frustrado, el equipo hall\u00f3 inspiraci\u00f3n para crear una base de datos que abordara los desaf\u00edos a los que se enfrentaban en DoubleClick.</p> <p>MongoDB es una de las bases de datos NoSQL m\u00e1s conocidas. Sigue un modelo de datos documental.</p> <p>Info</p> <p>Como curiosidad, su nombre viene de la palabra inglesa humongous, que significa gigantesco/enorme.</p> <p>En este apartado exploraremos c\u00f3mo MongoDB se integra perfectamente en los entornos de Big Data, ofreciendo capacidades escalables, flexibles y de alto rendimiento para abordar una variedad de desaf\u00edos y escenarios de datos a gran escala. Desde su modelo de datos flexible hasta su capacidad para manejar grandes vol\u00famenes de datos en tiempo real, MongoDB se ha convertido en una herramienta indispensable para empresas y organizaciones que buscan aprovechar al m\u00e1ximo sus datos en el mundo del Big Data.</p> <p>Fuentes utilizadas</p> <ul> <li>Manual oficial de MongoDB</li> <li>Apuntes MongoDB. Sergio Rey Mart\u00ednez</li> <li>Aitor Medrano. Cursos Inteligencia Artificial y Big Data. Almacen de datos NoSQL</li> <li>Algunos ejemplos de uso</li> <li>Manipulaci\u00f3n de datos en MongoDB mediante Aggregation Pipeline</li> </ul>"},{"location":"mongodb/modelado/","title":"Dise\u00f1o de modelado de BD","text":""},{"location":"mongodb/modelado/#concepto-de-schemaless","title":"Concepto de schemaless","text":"<p>El t\u00e9rmino schemaless (sin esquema) se refiere a la capacidad de una base de datos para manejar datos sin una estructura fija predefinida. En el contexto de MongoDB, esto significa que no est\u00e1s obligado a definir un esquema estricto para tus datos antes de comenzar a almacenarlos. En lugar de eso, los datos se almacenan en documentos BSON (Binary JSON), y estos documentos pueden tener una estructura flexible y pueden variar de un documento a otro dentro de la misma colecci\u00f3n.</p> <p>A continuaci\u00f3n, profundicemos en algunos aspectos clave del concepto de schemaless en MongoDB:</p> <ul> <li>Flexibilidad de estructura: Los documentos en MongoDB pueden contener diferentes campos y tipos de datos. No es necesario que todos los documentos en una colecci\u00f3n tengan la misma estructura. Esto permite adaptarse f\u00e1cilmente a cambios en los requisitos de la aplicaci\u00f3n sin tener que modificar un esquema centralizado.</li> <li>Adici\u00f3n din\u00e1mica de campos: En MongoDB, puedes agregar campos a un documento en cualquier momento sin afectar a otros documentos en la misma colecci\u00f3n. Esto significa que puedes manejar datos evolutivos donde la estructura de los documentos puede cambiar con el tiempo.</li> <li>Consulta sin restricciones: Dado que no hay un esquema fijo que imponga restricciones sobre la estructura de los datos, las consultas en MongoDB pueden ser m\u00e1s flexibles. Puedes realizar consultas sobre cualquiers campo en cualquier documento, incluso si esos campos no est\u00e1n presentes en todos los documentos de la colecci\u00f3n.</li> <li>Evita la migraci\u00f3n de esquemas: En las bases de datos tradicionales con esquemas fijos, los cambios en el esquema requieren migraciones de datos costosas. Con MongoDB, puedes evitar este problema ya que no hay un esquema centralizado que necesite ser modificado.</li> <li>Agilidad en el desarrollo: La falta de un esquema fijo permite una mayor agilidad en el desarrollo de aplicaciones, ya que puedes iterar r\u00e1pidamente y ajustar el modelo de datos seg\u00fan sea necesario sin tener que preocuparte por actualizar un esquema centralizado.</li> <li>Rendimiento: La flexibilidad del modelo de datos schemaless puede traducirse en un mejor rendimiento en ciertos casos, ya que elimina la necesidad de realizar un join de datos dispersos en m\u00faltiples tablas, como suele ocurrir en bases de datos relacionales.</li> </ul> <p>A pesar de las ventajas de un modelo de datos schemaless, es importante tener en cuenta que esto tambi\u00e9n puede presentar desaf\u00edos, especialmente en t\u00e9rminos de mantener la coherencia y la integridad de los datos. Por lo tanto, es crucial dise\u00f1ar cuidadosamente la base de datos y utilizar pr\u00e1cticas como la validaci\u00f3n de datos y la indexaci\u00f3n adecuada para garantizar un rendimiento \u00f3ptimo y la integridad de los datos en aplicaciones MongoDB.</p> <p>Observar la diferencia que tenemos en el dise\u00f1o de la bases de datos relacionales con las NoSQL como lo vimos anteriormente</p>"},{"location":"mongodb/modelado/#documentos-embebidos","title":"Documentos embebidos","text":"<p>El concepto de embebido hace referencia a guardar una \u2018cosa\u2019 dentro de otra \u2018cosa\u2019. En este caso, guardar un documento JSON dentro de otro como valor de una de sus propiedades.</p> <p>Por ejemplo, supongamos que tenemos una colecci\u00f3n que guarda datos sobre cursos que se est\u00e1n impartiendo, en una base de datos relacional ser\u00edan dos tablas, pero en MongoDB lo hacemos en una \u00fanica colecci\u00f3n:</p> <pre><code>{\n    id: 1,\n    referencia: 'C0001',\n    nombre: 'Curso de especializaci\u00f3n de Inteligencia Artificial y Big Data',\n    fechaInicio: new Date(\"2025-10-01\"),\n    activo: true,\n    asignaturas: [\n        {\n            codAsig: 101,\n            nombre: 'Sistemas de Big Data',\n            horasSemana: 3,\n            profesores: [\n                {\n                    codProf: 302,\n                    nombre: 'Alberto Aparicio',\n                    rol: 'Profesor'\n                },\n                {\n                    codProf: 901,\n                    nombre: 'Jorge Soro',\n                    rol: 'Especialista'\n                }\n            ]\n        },\n        {\n            codAsig: 102,\n            nombre: 'Big Data Aplicado',\n            horasSemana: 3,\n            profesores: [\n                {\n                    codProf: 301,\n                    nombre: 'Nacho Pach\u00e9s',\n                    rol: 'Profesor'\n                },\n                {\n                    codProf: 901,\n                    nombre: 'Jorge Soro',\n                    rol: 'Especialista'\n                }\n            ]\n        }\n    ],\n    alumnos: []\n}\n</code></pre>"},{"location":"mongodb/modelado/#documentos-referenciados","title":"Documentos referenciados","text":"<p>El concepto referenciado a diferencia de los documentos embebidos, en un documento JSON se guarda solo el valor de una o varias propiedades, en lugar del documento completo.</p> <p>Normalmente, se guarda el valor de una propiedad que identifica un\u00edvocamente, al documento referenciado: por ejemplo en el caso anterior podr\u00edamos tener:</p> <pre><code>{\n    id: 1,\n    referencia: 'C0001',\n    nombre: 'Curso de especializaci\u00f3n de Inteligencia Artificial y Big Data',\n    fechaInicio: new Date(\"2025-10-01\"),\n    activo: true,\n    asignaturas: [ 101, 102],\n    alumnos: []\n}\n</code></pre> <p>En este caso, las asignaturas se refer\u00e9ncian mediante el c\u00f3digo de identificaci\u00f3n, en lugar de guardar en el JSON todos los datos. De esta forma es similar al adoptado por las bases de datos relacionales.</p> <p>Esto plantea varias ventajas y desventajas:</p> <p>As\u00ed pues en los documentos embebidos tenemos: </p> <ul> <li>Ventajas: <ul> <li>Al recuperar un curso, podemos traernos toda la informaci\u00f3n relacionada en otras colecciones (p.e. asignaturas) </li> </ul> </li> <li>Desventajas: <ul> <li>Al hacer consultas sobre la colecci\u00f3n externa (cursos), si uno de los criterios afecta a la informaci\u00f3n de los documentos embebidos, el tiempo para realizar dicha consulta se ver\u00e1 incrementando. </li> <li>Las actualizaciones ser\u00e1n m\u00e1s costosas si alguna de las propiedades a actualizar pertenece al documento embebido.</li> </ul> </li> </ul> <p>Mientras que en los documentos referenciados:</p> <ul> <li>Ventajas: <ul> <li>Las consultas sobre la colecci\u00f3n principal y las relacionadas se ejecutar\u00e1 m\u00e1s r\u00e1pido. </li> <li>Al actualizar informaci\u00f3n relacionada, se hace directamente en sus documentos sin tener que revisar la colecci\u00f3n externa. </li> </ul> </li> <li>Desventajas: <ul> <li>Al recuperar un curso, habr\u00e1 que consultar los identificadores que relacionan a los documentos en otras colecciones y hacer consultas adicionales para obtener la informaci\u00f3n relacionada.</li> </ul> </li> </ul> <p>Entonces \u00bfQu\u00e9 dise\u00f1o elegir?</p> <p>Depender\u00e1 de: </p> <ul> <li>C\u00f3mo se quiere almacenar la informaci\u00f3n. </li> <li>la naturaleza y el contexto de las aplicaciones que vayan a consumir la informaci\u00f3n.</li> <li>Las preferencias de roles como arquitectos de software y de bases de datos teniendo en cuenta factores futuros como la Escalabilidad en cuanto a volumen de datos, usuarios / aplicaciones y sus formas de acceder a la informaci\u00f3n, etc.</li> </ul>"},{"location":"mongodb/mongodb/","title":"MongoDB","text":""},{"location":"mongodb/mongodb/#mongodb_1","title":"MongoDB","text":"<p>MongoDB es una base de datos NoSQL, de c\u00f3digo abierto y orientada a documentos. En lugar de almacenar datos en tablas, como lo hace una base de datos relacional, MongoDB almacena datos en documentos similares a JSON con un formato llamado BSON (Binary JSON).</p> <p>BSON extiende el formato JSON para incluir tipos de datos adicionales como fechas y binarios, lo que lo hace m\u00e1s adecuado para representar datos complejos.</p> <p>MongoDB destaca porque:</p> <ul> <li>Soporta esquemas din\u00e1micos: diferentes documentos de una misma colecci\u00f3n pueden tener atributos diferentes.</li> <li>Aunque inicialmente ten\u00eda un soporte limitado de joins, desde la versi\u00f3n 5.2 se pueden realizar incluso entre colecciones particionadas. Actualmente MongoDB va por la versi\u00f3n. 8.0.</li> <li>Soporte de transacciones s\u00f3lo a nivel de aplicaci\u00f3n. Lo que en un RDMS puede suponer m\u00faltiples operaciones, con MongoDB se puede hacer en una sola operaci\u00f3n al insertar/actualizar todo un documento de una sola vez, pero si queremos crear una transacci\u00f3n entre dos documentos, la gesti\u00f3n la debe realizar el driver.</li> </ul> <p>MongoDB se utiliza ampliamente en una variedad de aplicaciones, incluidas aquellas con grandes vol\u00famenes de datos, cargas de trabajo de alta velocidad y requisitos de flexibilidad de esquema. Es especialmente popular en aplicaciones web y m\u00f3viles, as\u00ed como en entornos de Big Data y an\u00e1lisis en tiempo real.</p> <p>Ejemplos muestran la versatilidad de MongoDB en diferentes sectores podr\u00edan ser:</p> <ul> <li> <p>eBay: Utiliza MongoDB para gestionar su enorme cat\u00e1logo de productos y facilitar b\u00fasquedas r\u00e1pidas y eficientes.</p> </li> <li> <p>Uber: Emplea MongoDB para almacenar datos de viajes y usuarios, permitiendo un an\u00e1lisis en tiempo real y mejorando la experiencia del cliente.</p> </li> <li> <p>LinkedIn: Utiliza MongoDB para manejar grandes vol\u00famenes de datos de usuarios y conexiones, optimizando la b\u00fasqueda y la interacci\u00f3n en la plataforma.</p> </li> <li> <p>Foursquare: Esta aplicaci\u00f3n de recomendaciones de lugares utiliza MongoDB para gestionar datos de usuarios y localizaciones, permitiendo un acceso r\u00e1pido a informaci\u00f3n geoespacial.</p> </li> <li>The Guardian: El medio de comunicaci\u00f3n utiliza MongoDB para gestionar su contenido digital, facilitando la publicaci\u00f3n y el acceso a art\u00edculos y multimedia de manera eficiente.</li> </ul>"},{"location":"mongodb/mongodb/#caracteristicas-de-mongodb","title":"Caracter\u00edsticas de MongoDB","text":"<p>Si tuvi\u00e9ramos que resumir a una la principal caracter\u00edstica a destacar de MongoDB, sin duda esta ser\u00eda la velocidad, que alcanza un balance perfecto entre rendimiento y funcionalidad gracias a su sistema de consulta de contenidos. Pero sus caracter\u00edsticas principales no se limitan solo a esto, MongoDB cuenta, adem\u00e1s, con otras que lo posicionan posiblemente como la base de datos NoSQL m\u00e1s popular para muchos desarrolladores.</p> <p>Caracter\u00edsticas principales:</p> <ul> <li>Consultas ad hoc. Con MongoDb podemos realizar todo tipo de consultas. Podemos hacer b\u00fasqueda por campos, consultas de rangos y expresiones regulares. Adem\u00e1s, estas consultas pueden devolver un campo espec\u00edfico del documento, pero tambi\u00e9n puede ser una funci\u00f3n JavaScript definida por el usuario.</li> <li>Indexaci\u00f3n. El concepto de \u00edndices en MongoDB es similar al empleado en bases de datos relacionales, con la diferencia de que cualquier campo documentado puede ser indexado y a\u00f1adir m\u00faltiples \u00edndices secundarios.</li> <li>Replicaci\u00f3n. Del mismo modo, la replicaci\u00f3n es un proceso b\u00e1sico en la gesti\u00f3n de bases de datos. MongoDB soporta el tipo de replicaci\u00f3n primario-secundario. De este modo, mientras podemos realizar consultas con el primario, el secundario act\u00faa como r\u00e9plica de datos en solo lectura a modo copia de seguridad con la particularidad de que los nodos secundarios tienen la habilidad de poder elegir un nuevo primario en caso de que el primario actual deje de responder.</li> <li>Balanceo de carga. Resulta muy interesante c\u00f3mo MongoDB puede escalar la carga de trabajo. MongoDB tiene la capacidad de ejecutarse de manera simult\u00e1nea en m\u00faltiples servidores, ofreciendo un balanceo de carga o servicio de replicaci\u00f3n de datos, de modo que podemos mantener el sistema funcionando en caso de un fallo del hardware.</li> <li>Almacenamiento de archivos. Aprovechando la capacidad de MongoDB para el balanceo de carga y la replicaci\u00f3n de datos, Mongo puede ser utilizado tambi\u00e9n como un sistema de archivos. Esta funcionalidad, llamada GridFS e incluida en la distribuci\u00f3n oficial, permite manipular archivos y contenido.</li> <li>Ejecuci\u00f3n de JavaScript del lado del servidor. MongoDB tiene la capacidad de realizar consultas utilizando JavaScript, haciendo que estas sean enviadas directamente a la base de datos para ser ejecutadas.</li> </ul>"},{"location":"mongodb/mongodb/#conceptos-basicos","title":"Conceptos b\u00e1sicos","text":"<p>Hay una serie de conceptos que conviene conocer antes de entrar en detalle:</p> <ul> <li>MongoDB tienen el mismo concepto de base de datos que un RDMS. Dentro de una instancia de MongoDB podemos tener 0 o m\u00e1s bases de datos, actuando cada una como un contenedor de alto nivel.</li> <li>Una base de datos tendr\u00e1 0 o m\u00e1s colecciones. Una colecci\u00f3n es muy similar a lo que entendemos como tabla dentro de un RDMS. MongoDB ofrece diferentes tipos de colecciones, desde las normales cuyo tama\u00f1o crece conforme lo hace el n\u00famero de documentos, como las colecciones capped, las cuales tienen un tama\u00f1o predefinido y que pueden contener una cierta cantidad de informaci\u00f3n que se sustituir\u00e1 por nueva cuando se llene.</li> <li>Las colecciones contienen 0 o m\u00e1s documentos, por lo que es similar a una fila o registro de un RDMS.</li> <li>Cada documento contiene 0 o m\u00e1s atributos, compuestos de parejas clave/valor. Cada uno de estos documentos no sigue ning\u00fan esquema, por lo que dos documentos de una misma colecci\u00f3n pueden contener todos los atributos diferentes entre s\u00ed.</li> </ul> Elementos de MongoDB <p>As\u00ed pues, tenemos que una base de datos va a contener varias colecciones, donde cada colecci\u00f3n contendr\u00e1 un conjunto de documentos. Podemos hacer una correspondencia r\u00e1pida entre bases de datos Relacionales y NoSQL:</p> <p>Adem\u00e1s, MongoDB soporta \u00edndices, igual que cualquier RDMS, para acelerar la b\u00fasqueda de datos. Al realizar cualquier consulta, se devuelve un cursor, con el cual podemos hacer cosas tales como contar, ordenar, limitar o saltar documentos</p>"},{"location":"mongodb/mongodb/#bson","title":"BSON","text":"<p>MongoDB almacena los documentos mediante BSON (Binary JSON). Repasemos el concepto de JSON: JavaScript Object Notation:</p> <ul> <li>Formato de texto sencillo para el intercambio de datos.</li> <li>Subconjunto de la notaci\u00f3n literal de objetos de JavaScript.</li> <li>Alternativa a XML como lenguaje de intercambio de datos. Mucho m\u00e1s sencillo de leer y escribir.</li> <li>Uso extendido en bases de datos noSQL, entre ellas JSON: JavaScript Object Notation</li> <li>Ampliamente soportado por multitud de lenguajes de programaci\u00f3n.</li> <li>Un objeto JSON est\u00e1 formado por uno o varios pares string: value (cadena:valor).</li> <li>Soporta diferentes tipos de datos como cadenas de texto, n\u00fameros, fecha, hora, valores nulos y booleanos.de JSON: JavaScript Object Notation:</li> </ul> Documento en MongoDB <p>Mediante JavaScript podemos crear objetos que se representan con JSON. Internamente, MongoDB almacena los documentos mediante BSON (Binary JSON). Podemos consultar la especificaci\u00f3n en la web oficial de BSON</p> <p>BSON representa un superset de JSON ya que: - Permite almacenar datos en binario - Incluye un conjunto de tipos de datos no incluidos en JSON, como pueden ser ObjectId, Date o BinData. Podemos consultar todos los tipos que soporta un objeto BSON en http://docs.mongodb.org/manual/reference/bson-types/</p> <p>Un ejemplo de un objeto BSON podr\u00eda ser: <pre><code>var yo = {\n  nombre: \"Alberto\",\n  apellidos: \"Aparicio\",\n  fnac: new Date(\"Aug 13, 1975\"),\n  hobbies: [\"programaci\u00f3n\", \"ciclismo\", \"m\u00fasica\"],\n  casado: true,\n  hijos: 2,\n  contacto: {\n    twitter: \"@alapvi\",\n    email: \"a.apariciovi@edu.gva.es\"\n  },\n  fechaCreacion: new Timestamp()\n}\n</code></pre></p> <p>Los documentos BSON tienen las siguientes restricciones:</p> <ul> <li>No pueden tener un tama\u00f1o superior a 16 MB.</li> <li>El atributo <code>_id</code> queda reservado para la clave primaria.</li> <li>Desde MongoDB 5.0 los nombres de los campos pueden empezar por $ y/o contener el ., aunque en la medida de lo posible, es recomendable evitar su uso.</li> </ul> <p>Adem\u00e1s MongoDB: - No asegura que el orden de los campos se respete. - Es sensible a los tipos de los datos - Es sensible a las may\u00fasculas.</p> <p>Por lo que estos documentos son distintos:</p> <pre><code>{\"edad\": \"18\"}\n{\"edad\": 18}\n{\"Edad\": 18}\n</code></pre> <p>Si queremos validar si un documento JSON es v\u00e1lido, podemos usar la web JSONLint Validator and Formatter. Hemos de tener en cuenta que s\u00f3lo valida JSON y no BSON, por tanto nos dar\u00e1 errores en los tipos de datos propios de BSON.</p>"},{"location":"mongodb/mongodbcrud/","title":"Operaciones con datos CRUD","text":"<p>En MongoDB, las operaciones CRUD (Crear, Leer, Actualizar, Eliminar) se realizan utilizando m\u00e9todos espec\u00edficos. Aqu\u00ed te muestro c\u00f3mo realizar cada una de estas operaciones.</p> <p>Antes de comenzar a trabajar, debemos entrar en una de las bases de datos con <code>use</code> y en todo momento podemos ver las colecciones que tenemos en esta base de datos con <code>use</code></p>"},{"location":"mongodb/mongodbcrud/#insertar","title":"Insertar","text":"<p>Para insertar documentos en una colecci\u00f3n, se utiliza el m\u00e9todo <code>insertOne()</code> o <code>insertMany()</code>.</p>"},{"location":"mongodb/mongodbcrud/#insertone","title":"InsertOne()","text":"<ul> <li><code>db.collectionName.insertOne(&lt;json&gt;)</code>: Inserta un solo documento.</li> </ul> MongoDB. Inserci\u00f3n en colecci\u00f3n <p>Ejemplos:</p> <ul> <li>Insertar un solo documento en la colecci\u00f3n <code>usuarios</code>: <pre><code>db.usuarios.insertOne({\n    nombre: \"Juan\",\n    edad: 30,\n    ciudad: \"Barcelona\"\n});\n</code></pre> <pre><code>db.usuarios.insertOne({\n    nombre: \"Pepe\",\n    edad: 34,\n    ciudad: \"Valencia\",\n    intereses: [\"f\u00fatbol\", \"m\u00fasica\"],\n    direccion: { calle: \"Calle Mayor\", numero: 123 },\n    fechaRegistro: new Date(),\n    activo: true\n});\n</code></pre></li> <li>Insertar un documento con una fecha espec\u00edfica:<ul> <li>Los campos antes no estaban entre comillas y en este ejemplo si lo estan; es totalmente indiferente. Pero si debemos tener en cuenta que es case-sensitive (May\u00fasculas/Min\u00fasculas) es importante y adcem\u00e1s tambi\u00e9n cambia si ponemos los datos n\u00famericos entre comillas o no, ya que se convierten en texto: <pre><code>db.usuarios.insertOne({\n    \"nombre\": \"Filiberto\",\n    \"edad\" : \"33\",\n    \"fechaNacimiento\": new Date(\"2004-03-15\"),\n    \"ciudad\": \"Alacant\"\n});\n</code></pre></li> </ul> </li> </ul> <p>Cada vez que hacemos una inserci\u00f3n, si es correcta, nos devuelve el resultado del con el siguiente formato: <pre><code>{\n  acknowledged: true,\n  insertedId: ObjectId('6888d00e75fc26a2b289b03d')\n}\n</code></pre></p>"},{"location":"mongodb/mongodbcrud/#insertmany","title":"InsertMany()","text":"<ul> <li><code>db.collectionName.insertMany(&lt;json&gt;)</code>: Inserci\u00f3n de varios elementos.</li> </ul> <p>Como se trata de una inserci\u00f3n de un conjunto de documentos, lo que hacemos en pasar un array y esto se hace mediante el uso de corchetes : <code>[]</code>.</p> <p>Ejemplos:</p> <ul> <li>Insertar varios documentos en la colecci\u00f3n 'usuarios': <pre><code>db.usuarios.insertMany([\n    { nombre: \"Ana\", edad: 25, ciudad: \"Madrid\" },\n    { nombre: \"Carlos\", edad: 35, ciudad: \"Valencia\" }\n]);\n</code></pre></li> <li>Insertar varios documentos en la colecci\u00f3n 'usuarios':</li> </ul> <p><pre><code>db.usuarios.insertMany([\n    { nombre: \"Ana\", edad: 25, ciudad: \"Madrid\", intereses: [\"viajes\"], fechaRegistro: new Date(), activo: false },\n    { nombre: \"Carlos\", edad: 35, ciudad: \"Valencia\", intereses: [\"lectura\"], fechaRegistro: new Date(), activo: true }\n]);\n</code></pre> Observar c\u00f3mo se trabaja con las fechas</p>"},{"location":"mongodb/mongodbcrud/#leerconsultar","title":"Leer/Consultar","text":"<p>Uno de los aspectos m\u00e1s interesantes de las bases de datos es la capacidad para realizar consultas, por lo que ahora vamos a ver de forma muy breve como leer datos, pero m\u00e1s adelante profundizaremos en la realizaci\u00f3n de consultas m\u00e1s elaboradas.</p>"},{"location":"mongodb/mongodbcrud/#find","title":"<code>find()</code>","text":"<p>Para leer datos de una colecci\u00f3n, se utiliza el m\u00e9todo <code>find()</code>.</p> <ul> <li>Leer todos los documentos de la colecci\u00f3n 'usuarios' <pre><code>db.usuarios.find();\n</code></pre></li> <li>Leer todos los documentos de la colecci\u00f3n <code>'usuarios'</code> y formatear la salida <code>json</code> <pre><code>db.usuarios.find().pretty();\n</code></pre></li> </ul> <p>Note</p> <p>La funci\u00f3n <code>pretty()</code> en MongoDB sigue siendo efectiva, pero su uso ha cambiado con las versiones m\u00e1s recientes. En mongosh (la nueva shell de MongoDB), pretty() no altera el formato de salida, mientras que en la shell legacy (mongo shell), s\u00ed lo hac\u00eda, mostrando los resultados de manera m\u00e1s legible.</p> <ul> <li>Leer documentos que coincidan con un criterio espec\u00edfico <pre><code>db.usuarios.find({ ciudad: \"Barcelona\" });\n</code></pre></li> <li> <p>Leer documentos que coincidan con un criterio espec\u00edfico (por ejemplo, ciudad igual a 'Madrid' y activo igual a false) <pre><code>db.usuarios.find({ ciudad: \"Madrid\", activo: false });\n</code></pre> Podemos especificar los campos que queremos recuperar en la consulta:</p> </li> <li> <p>Leer documentos con proyecci\u00f3n (seleccionar campos espec\u00edficos): <pre><code>db.usuarios.find({}, { nombre: 1, edad: 1 });\n</code></pre></p> </li> <li>Leer documentos con proyecci\u00f3n (seleccionar campos espec\u00edficos) <pre><code>db.usuarios.find({}, { nombre: 1, edad: 1, _id: 0 });\n</code></pre></li> </ul> <p>Para proyectar un campo en el resultado de la consulta el formato a utilizar es <code>NombreDeCampo: 1</code>. </p> <p>Acerca de las proyecciones</p> <p>MongoDB no permite mezclar inclusi\u00f3n y exclusi\u00f3n en la misma proyecci\u00f3n, salvo una excepci\u00f3n espec\u00edfica con el campo <code>_id</code>.</p> <ul> <li> <p>Regla general de proyecciones</p> <ul> <li>Puedes:<ul> <li>Incluir campos: <code>{ nombre: 1, edad: 1 }</code></li> <li>Excluir campos: <code>{ direccion: 0, telefono: 0 }</code></li> </ul> </li> <li>No se puede mezclar los dos: <code>{ nombre: 1, edad: 1, direccion: 0 }</code> --&gt; Error</li> </ul> </li> </ul> <ul> <li>Leer usuarios cuya fecha de registro fue despu\u00e9s de una fecha espec\u00edfica: <pre><code>db.usuarios.find({ fechaRegistro: { $gt: new Date(\"2024-01-01\") } });\n</code></pre></li> <li>Leer usuarios cuya fecha de registro est\u00e1 entre un rango de fechas: <pre><code>db.usuarios.find({ fechaRegistro: { $gt: new Date(\"2024-01-01\"), $lt: new Date(\"2025-01-01\") } });\n</code></pre></li> </ul> <p>Note</p> <p>No profundizamos m\u00e1s en las b\u00fasquedas porque m\u00e1s adelante dedicaremos un punto completo a explicar las b\u00fasquedas en m\u00e1s profundidad.</p>"},{"location":"mongodb/mongodbcrud/#actualizar","title":"Actualizar","text":"<p>Para actualizar documentos en una colecci\u00f3n, se utiliza el m\u00e9todo <code>updateOne()</code> o <code>updateMany()</code>.</p>"},{"location":"mongodb/mongodbcrud/#updateone","title":"<code>updateOne()</code>","text":"<ul> <li><code>db.collection.updateOne(&lt;filter&gt;, &lt;update&gt;)</code></li> </ul> <p>El m\u00e9todo <code>updateOne()</code> se utiliza para actualizar un solo documento que coincida con un criterio espec\u00edfico. Si hay varios documentos que coinciden con el criterio, solo se actualizar\u00e1 el primero que se encuentre.</p> <p>En la clausula de actualizaci\u00f3n tenemos el comando <code>$set</code>. Adem\u00e1s debemos tener en cuenta que tanto el <code>&lt;filter&gt;</code> como la <code>&lt;update&gt;</code> son <code>json</code> por lo que deben estar comprendidos entre corchetes:</p> <pre><code>db.collection.updateOne({}, {$set:{}});\n</code></pre> <p>Veamos algunos ejemplos</p> <ul> <li>Ejemplo de <code>updateOne()</code></li> </ul> <pre><code>db.usuarios.updateOne(\n    { nombre: \"Juan\" },\n    { $set: { edad: 31 } }\n);\n</code></pre> <ul> <li>Cambiamos m\u00e1s de un valor</li> </ul> <pre><code>db.usuarios.updateOne(\n    { nombre: \"Juan\" },\n    { $set: { edad: 31, ciudad: 'Albacete' } }\n);\n</code></pre> <ul> <li>Actualizar la fecha de un evento espec\u00edfico</li> </ul> <pre><code>db.usuarios.updateOne(\n    { nombre: \"Alberto\" },\n    { $set: { fechaRegistro: new Date(\"2024-03-20\") } }\n);\n</code></pre> <p>En el primer ejemplo, se actualizar\u00e1 el primer documento de la colecci\u00f3n <code>\"usuarios\"</code> que tenga el campo nombre igual a <code>\"Juan\"</code>. Si hay varios documentos con ese nombre, solo se actualizar\u00e1 uno.</p> <p>Una vez realizada la actualizaci\u00f3n, MongoDB avisa:</p> <pre><code>{\n  acknowledged: true,\n  insertedId: null,\n  matchedCount: 1,\n  modifiedCount: 1,\n  upsertedCount: 0\n}\n</code></pre>"},{"location":"mongodb/mongodbcrud/#updatemany","title":"<code>updateMany()</code>","text":"<ul> <li><code>db.collection.updateMany(&lt;filter&gt;, &lt;update&gt;)</code></li> </ul> <p>Por otro lado, el m\u00e9todo <code>updateMany()</code> se utiliza para actualizar m\u00faltiples documentos que coincidan con un criterio espec\u00edfico. Todos los documentos que cumplan el criterio ser\u00e1n actualizados.</p> <ul> <li>Ejemplo de <code>updateMany()</code></li> </ul> <p><pre><code>db.usuarios.updateMany(\n    { ciudad: \"J\u00e1tiva\" },\n    { $set: { ciudad: \"X\u00e0tiva\" } }\n);\n</code></pre> En este ejemplo, se actualizar\u00e1n todos los documentos de la colecci\u00f3n <code>\"usuarios\"</code> que tengan el campo ciudad igual a \"J\u00e1tiva\", estableciendo su valor a \"X\u00e0tiva\".</p> <p>Por tanto, <code>updateOne()</code> es \u00fatil cuando solo quieres actualizar un \u00fanico documento, mientras que <code>updateMany()</code> es \u00fatil cuando necesitas actualizar m\u00faltiples documentos que cumplan un criterio espec\u00edfico.</p> <p>Adem\u00e1s de establecer un valor en una actualizaci\u00f3n, tenemos otras opciones para las modificaciones a aplicar. Utiliza operadores como:</p> <ul> <li><code>$set</code>: Para establecer un nuevo valor.</li> <li><code>$unset</code>: Para eliminar un campo.</li> <li><code>$inc</code>: Para incrementar un valor num\u00e9rico.</li> <li><code>$push</code>: Para agregar un elemento a un array.</li> </ul> <p>En el siguiente ejemplo, incrementamos un a\u00f1o la edad de los usuarios con un determinado nombre;</p> <pre><code>db.usuarios.updateMany(\n    { nombre : \"Juan\" },\n    { $inc: { edad: 1 } }\n);\n</code></pre>"},{"location":"mongodb/mongodbcrud/#replaceone","title":"<code>replaceOne()</code>","text":"<ul> <li><code>db.collection.replaceOne(&lt;filter&gt;, &lt;update&gt;)</code></li> </ul> <p>Reemplazo completo de un documento. En este caso, al reemplazar el documento que encontramos por una nuevo, no necesitamos el comando $set</p> <ul> <li>Ejemplo donde reemplaza el primer registro qe encuentra con el filtro aplicado</li> </ul> <pre><code>db.usuarios.replaceOne(\n    { nombre: \"Alberto\" },\n    {     \n        nombre: \"Alberto A.\",\n        edad: 18,\n        ciudad: \"X\u00e0tiva\",\n        intereses: [\"Baloncesto\", \"Inform\u00e1tica\"],\n        fechaRegistro: new Date(),\n        activo: true \n    }\n);\n</code></pre> <p>En este caso, vamos a ver su ejecuci\u00f3n, donde veremos incluso que al cambiar el nombre, este campo tambi\u00e9n cambia aunque se el utilizado para hacer la b\u00fasqueda:</p> Reemplazando documentos en MongoDB"},{"location":"mongodb/mongodbcrud/#eliminar","title":"Eliminar","text":"<p>Para eliminar documentos de una colecci\u00f3n, se utiliza el m\u00e9todo <code>deleteOne()</code> o <code>deleteMany()</code>. En MongoDB, tanto <code>deleteOne()</code> como <code>deleteMany()</code> son m\u00e9todos utilizados para eliminar documentos de una colecci\u00f3n. Aqu\u00ed tienes las diferencias entre ellos:</p>"},{"location":"mongodb/mongodbcrud/#deleteone","title":"<code>deleteOne()</code>","text":"<p>El m\u00e9todo <code>deleteOne()</code> se utiliza para eliminar un solo documento que coincida con un criterio espec\u00edfico. Si hay varios documentos que coinciden con el criterio, solo se eliminar\u00e1 el primero que se encuentre.</p> <ul> <li>Ejemplo de <code>deleteOne()</code></li> </ul> <pre><code>db.usuarios.deleteOne({ nombre: \"Juan\" });\n</code></pre> <p>En este ejemplo, se eliminar\u00e1 el primer documento de la colecci\u00f3n <code>\"usuarios\"</code> que tenga el campo nombre igual a <code>\"Juan\"</code>. Si hay varios documentos con ese nombre, solo se eliminar\u00e1 uno.</p>"},{"location":"mongodb/mongodbcrud/#deletemany","title":"<code>deleteMany()</code>","text":"<p>Por otro lado, el m\u00e9todo <code>deleteMany()</code> se utiliza para eliminar varios documentos que coincidan con un criterio espec\u00edfico. Todos los documentos que cumplan el criterio ser\u00e1n eliminados.</p> <ul> <li>Ejemplo de <code>deleteMany()</code></li> </ul> <pre><code>db.usuarios.deleteMany({ activo: false });\n</code></pre> <p>En este ejemplo, se eliminar\u00e1n todos los documentos de la colecci\u00f3n <code>\"usuarios\"</code> que tengan el campo <code>activo</code> igual a <code>false</code>.</p> <p>Otros ejemplos</p> <ul> <li>Eliminar varios documentos que cumplan el criterio especificado</li> </ul> <pre><code>db.usuarios.deleteMany({ ciudad: \"X\u00e0tiva\" });\n</code></pre> <ul> <li>Eliminar usuarios con una fecha de registro espec\u00edfica</li> </ul> <pre><code>db.usuarios.deleteMany({ fecha: { $lt: new Date(\"2025-01-01\") } });\n</code></pre> <p>Cuidado!</p> <p>Como siempre debemos tener cuidad a la hora de borrar, de hecho si hacemos <pre><code>db.usuarios.deleteMany({});\n</code></pre></p> <p>Nos borrar\u00e1 todos los documentos de la colecci\u00f3n.</p> <p>Uso de json</p> <p>Siempre se debe pasar un <code>json</code> dentro de la condici\u00f3n, o sea, dentro de los par\u00e9ntesis deben haber llaves:</p> <pre><code>db.usuarios.deleteMany();     //error\ndb.usuarios.deleteMany({});   //correcto: json vac\u00edo\n</code></pre> <p>Ahora que ya tenemos m\u00e1s herramientas y hemos visto las operaciones b\u00e1sicas de MongoDB en la siguiente secci\u00f3n vamos a profundizar sobre las consultas de los datos, aunque ya las hemos visto brevemente con anterioridad. </p>"},{"location":"mongodb/mongodbdatos/","title":"Operaciones con datos: Consultas y m\u00e9todos","text":"<p>Ahora que ya tenemos m\u00e1s herramientas y hemos visto las operaciones b\u00e1sicas de MongoDB vamos a profundizar sobre las consultas de los datos, aunque ya las hemos visto brevemente con anterioridad.</p> <p>Aprovechamos para introducir una base de datos con una colecci\u00f3n con datos de prueba. En el siguiente enlace tenemos una base de datos de pel\u00edculas que podemos introducir en MongoDB por ejemplo usando en MongoDB Compass. Para ello creamos una base de datos llamada consultas e importamos el fichero descargado.</p> <p>El comando b\u00e1sico es <code>.find()</code></p> <pre><code>db.collection.find()            // devuelve todos los documentos\ndb.collection.find(&lt;filter&gt;)    // devuelve los documentos que cumplen el filtro\n</code></pre>"},{"location":"mongodb/mongodbdatos/#operadores-mongodb","title":"Operadores MongoDB","text":"<p>Antes de continuar, en la siguiente tabla esta el listado de los principales operadores utilizados en consultas MongoDB para la construcci\u00f3n de los filtros:</p> Operador Descripci\u00f3n Ejemplo <code>$eq</code> Igualdad <code>db.collection.find({campo: {$eq: valor}})</code> <code>$ne</code> No igual <code>db.collection.find({campo: {$ne: valor}})</code> <code>$gt</code> Mayor que <code>db.collection.find({campo: {$gt: valor}})</code> <code>$gte</code> Mayor o igual que <code>db.collection.find({campo: {$gte: valor}})</code> <code>$lt</code> Menor que <code>db.collection.find({campo: {$lt: valor}})</code> <code>$lte</code> Menor o igual que <code>db.collection.find({campo: {$lte: valor}})</code> <code>$in</code> Igual a cualquiera de los valores en un array <code>db.collection.find({campo: {$in: [valor1, valor2]}})</code> <code>$nin</code> No igual a ninguno de los valores en un array <code>db.collection.find({campo: {$nin: [valor1, valor2]}})</code> <code>$exists</code> Verifica si el campo existe <code>db.collection.find({campo: {$exists: true/false}})</code> <code>$type</code> Verifica el tipo de datos del campo <code>db.collection.find({campo: {$type: tipo}})</code> <code>$regex</code> Realiza una b\u00fasqueda de expresi\u00f3n regular <code>db.collection.find({campo: {$regex: /patr\u00f3n/}})</code> <code>$or</code> Realiza una disyunci\u00f3n l\u00f3gica <code>db.collection.find({$or: [{condici\u00f3n1}, {condici\u00f3n2}]})</code> <code>$and</code> Realiza una conjunci\u00f3n l\u00f3gica <code>db.collection.find({$and: [{condici\u00f3n1}, {condici\u00f3n2}]})</code> <code>$not</code> Niega una expresi\u00f3n <code>db.collection.find({campo: {$not: {condici\u00f3n}}})</code> <code>$nor</code> Realiza una disyunci\u00f3n negada <code>db.collection.find({$nor: [{condici\u00f3n1}, {condici\u00f3n2}]})</code> <p>Estos operadores son fundamentales para realizar consultas avanzadas en MongoDB, permitiendo filtrar y buscar documentos en funci\u00f3n de diferentes criterios. Puedes combinar estos operadores para construir consultas complejas y poderosas que se adapten a tus necesidades espec\u00edficas.</p>"},{"location":"mongodb/mongodbdatos/#consultas-con-find-ejemplos-practicos","title":"Consultas con <code>.find()</code>. Ejemplos pr\u00e1cticos.","text":"<p>Utilizando la tabla de movies vamos a realizar algunas consultas que servir\u00e1n para ilustrar los aspectos m\u00e1s interesantes de las b\u00fasquedas en MongoDB.</p> <p>Veamos un documento tipo: <pre><code>{\n  _id: ObjectId('573a1390f29313caabcd4135'),\n  plot: 'Three men hammer on an anvil and pass a bottle of beer around.',\n  genres: [ 'Short' ],\n  runtime: 1,\n  cast: [ 'Charles Kayser', 'John Ott' ],\n  num_mflix_comments: 1,\n  title: 'Blacksmith Scene',\n  fullplot: 'A stationary camera looks at a large anvil with a blacksmith behind it and one on either side. The smith in the middle draws a heated metal rod from the fire, places it on the anvil, and all three begin a rhythmic hammering. After several blows, the metal goes back in the fire. One smith pulls out a bottle of beer, and they each take a swig. Then, out comes the glowing metal and the hammering resumes.',\n  countries: [ 'USA' ],\n  released: ISODate('1893-05-09T00:00:00.000Z'),\n  directors: [ 'William K.L. Dickson' ],\n  rated: 'UNRATED',\n  awards: { wins: 1, nominations: 0, text: '1 win.' },\n  lastupdated: '2015-08-26 00:03:50.133000000',\n  year: 1893,\n  imdb: { rating: 6.2, votes: 1189, id: 5 },\n  type: 'movie',\n  tomatoes: {\n    viewer: { rating: 3, numReviews: 184, meter: 32 },\n    lastUpdated: ISODate('2015-06-28T18:34:09.000Z')\n  }\n}\n</code></pre></p> <p>Comenzamos con consultas sencillas y vamos incrementando el nivel.</p>"},{"location":"mongodb/mongodbdatos/#consultas-basicas","title":"Consultas b\u00e1sicas","text":"<ul> <li>Obtener pel\u00edculas lanzadas en el a\u00f1o 1983 :</li> </ul> <pre><code>db.movies.find({ year: 1993 })\n</code></pre> <ul> <li>Buscar pel\u00edculas de genero \"corto\" (<code>genres = short</code>)</li> </ul> <pre><code>db.movies.find({ genres: \"Short\" })\n</code></pre>"},{"location":"mongodb/mongodbdatos/#consultas-con-operadores-logicos","title":"Consultas con operadores l\u00f3gicos","text":"<ul> <li>Buscar pel\u00edculas de duraci\u00f3n (<code>runtime</code>) superior a 120 minutos</li> </ul> <pre><code>db.movies.find({ \"runtime\": { $gt: 120 } })\n</code></pre> <ul> <li>Buscar pel\u00edculas cuya duraci\u00f3n se encuentre entre 90 y 100 minutos ambos incluidos</li> </ul> <pre><code>db.movies.find({ \"runtime\": { $gte: 90, $lte: 120 } })\n</code></pre> <ul> <li>Buscar pel\u00edculas que no tengan puntuaci\u00f3n (UNRATED) y que duren m\u00e1s de 100 minutos.</li> </ul> <pre><code>db.movies.find({rated: \"UNRATED\",runtime: {$gt: 100} })\n</code></pre> <p>Equivale exactamente a</p> <pre><code>db.movies.find({$and: [ {rated: \"UNRATED\"},{runtime: {$gt: 100} }]})\ndb.movies.find({$and: [ {$or: [{rated: \"NOT RATED\"},{rated: \"UNRATED\"}]}, {runtime: {$gt: 100}} ]}  )\n</code></pre> <p>Nota</p> <p>Podemos utilizar <code>.size()</code> o <code>.count()</code> al final para hacer recuento y verificar que el resultado de las dos consultas anteriores son iguales.</p> <ul> <li> <p>Buscar las pel\u00edculas que han no han tenido escritores (writers):</p> <p>En este caso no debe existir la propiedad writers</p> </li> </ul> <pre><code>db.movies.find({\"writers\": { $exists: true }})\n</code></pre> <ul> <li> <p>Buscar las pel\u00edculas donde ha intervenido el actor \"Charles Kayser\", pero mostrar solo titulo, fecha de lanzamiento, idioma, director y premios ganados: <pre><code>db.movies.find({\n    \"cast\": \"Charles Kayser\"\n    }, {\n    \"title\": 1,\n    \"released\": 1,\n    \"languages\": 1,\n    \"directors\": 1,\n    \"awards\": 1,\n})\n</code></pre></p> </li> <li> <p>Buscar pel\u00edculas lanzadas en una fecha determinada, y mostrando unos campos determinados.: <pre><code>db.movies.find({\n    released: ISODate(\"1997-05-01T00:00:00.000Z\")\n    }, {\n    title: 1,\n    languages: 1,\n    released: 1,\n    directors: 1,\n    writers: 1,\n    countries: 1\n  }\n)\n</code></pre></p> </li> </ul>"},{"location":"mongodb/mongodbdatos/#consultas-sobre-objetos-anidados","title":"Consultas sobre objetos anidados","text":"<ul> <li>Buscar pel\u00edculas que han recibido m\u00e1s de 1000 votos en IMDb</li> </ul> <pre><code>db.movies.find({ \"imdb.votes\": { $gt: 1000 } })\n</code></pre> <ul> <li>Buscar las pel\u00edculas que han recibido alg\u00fan premio:</li> </ul> <pre><code>db.movies.find({\"awards.wins\": { $gt: 0 }})\n</code></pre> <ul> <li>Buscar las pel\u00edculas que han sido nominadas y mostrar solo el titulo, directores y a\u00f1o.</li> </ul> <pre><code>db.movies.find({\n    \"awards.nominations\": { $gt: 0 }\n  }, {\n    \"title\": 1,\n    \"directors\": 1,\n    \"year\": 1\n  })\n</code></pre> <ul> <li>Buscar pel\u00edculas con una puntuaci\u00f3n entre 3 y 4 en el rating de viewer en tomatoes. Mostrar solo algunos campos por simplicidad</li> </ul> <pre><code>db.movies.find(\n  { 'tomatoes.viewer.rating': { $gte: 3, $lt: 4 } },\n  { \n    title: 1, \n    languages: 1, \n    released: 1, \n    directors: 1, \n    'tomatoes.viewer': 1, \n    writers: 1, \n    countries: 1 \n  }\n)\n</code></pre>"},{"location":"mongodb/mongodbdatos/#consultas-con-expresiones-regulares","title":"Consultas con expresiones regulares","text":"<p>Si queremos realizar consultas sobre partes de un campo de texto, hemos de emplear expresiones regulares. Para ello, tenemos el operador <code>$regexp</code> o, de manera m\u00e1s sencilla, indicando como valor la expresi\u00f3n regular a cumplir:</p> <ul> <li>Buscar todas las pel\u00edculas (titulo, lenguaje, lanzamiento, directores y guionistas) que tenga el literal \"scene\" en el titulo</li> </ul> <pre><code>db.movies.find(\n    { title: { $regex: /scene/i } },\n    { title: 1, \n      languages: 1, released: 1, directors: 1, writers: 1, countries: 1 }\n)\n</code></pre> <p>equivale a:</p> <pre><code>db.movies.find(\n    { title: /scene/i },\n    { title: 1, languages: 1, released: 1, directors: 1, writers: 1, countries: 1 }\n)\n</code></pre> <ul> <li>Buscar pel\u00edculas que tengan en su sinopsis (fullplot) la palabra \"fire\", sean anteriores al 1980 y que sean del genero \"Shorts\"</li> </ul> <pre><code>db.movies.find(\n  {\n    fullplot: { $regex: /fire/i },\n    year: { $lt: 1980 },\n    genres: \"Short\"\n  }, \n  { \n    title: 1, \n    year: 1, \n    languages: 1, \n    fullplot: 1, \n    released: 1, \n    directors: 1, \n    writers: 1, \n    countries: 1 \n  }\n)\n</code></pre> <ul> <li>Buscar pelicuas que tengan cualquiera de estos actores: \"Tom Cruise\", \"Tom Hanks\" o un actor que contenga \"Smith\" en su nombre</li> </ul> <pre><code>db.movies.find({\n    cast: /Tom Cruise|Tom Hanks|Smith/\n  }, \n  { \n    _id: 0,\n    title: 1, \n    cast: 1,\n    year: 1\n  }\n)\n</code></pre> <p>Consulta de elementos de un array</p> <p>Mediante las expresiones regulares hemos visto c\u00f3mo se consulta de forma sencialla elementos de un array, sin embargo tenemos un filtro especifico para estos casos <code>$elemMatch</code></p> <p><code>db.movies.find({ cast: { $elemMatch: { $eq: \"Leonardo DiCaprio\" }}});</code></p> <p>Mientras que expresiones regulares encuentra elementos que coindicen parcial o totalmente, con este filtro buscamos elementos exactos.</p>"},{"location":"mongodb/mongodbdatos/#otros-metodos-interesantes","title":"Otros m\u00e9todos interesantes","text":"<p>Existen gran variedad de m\u00e9todos que nos permiten realizar todo tipo de consultas sobre una base de datos y m\u00e1s concretamente sobre una colecci\u00f3n.</p> <p>Un listado detallado de todos estos m\u00e9todos lo encontramos en la web oficial de MongoDB: MongoDB Manual - Collection Methods</p> <p>Pueden resultar interesante los siguientes:</p>"},{"location":"mongodb/mongodbdatos/#metodo-distinct","title":"M\u00e9todo <code>.distinct()</code>","text":"<p>Obtiene los valores diferentes de un campo de una colecci\u00f3n:</p> <pre><code>db.movies.distinct( 'genres' );\n</code></pre> <pre><code>db.movies.distinct( 'type' );\n</code></pre> <p>Estos dos ejemplos obtienen los diferentes valores de los atributos indicados.</p>"},{"location":"mongodb/mongodbdatos/#metodo-count","title":"M\u00e9todo <code>.count()</code>","text":"<p>Cuenta la cantidad de documentos que cumplen una condici\u00f3n.</p> <pre><code>db.movies.find({\n    year: { $lt: 2000 },\n    genres: \"Short\"\n}).count()\n</code></pre> <p>Obtenemos la cantidad de cortos de la colecci\u00f3n, posterior al a\u00f1o 2000</p> <ul> <li>Buscar la cantidad pel\u00edculas que tengan en su sinopsis (fullplot) la palabra \"fire\", sean anteriores al 1980 y que sean del genero \"Shorts\"</li> </ul> <pre><code>db.movies.find({\n    fullplot: { $regex: /fire/i },\n    year: { $lt: 1900 },\n    genres: \"Short\"\n}).count()\n</code></pre>"},{"location":"mongodb/mongodbdatos/#metodo-limit","title":"M\u00e9todo <code>.limit()</code>","text":"<p>Muestra una cantidad de documentos indicada que cumplan una condici\u00f3n.</p> <pre><code>db.movies.find({\n    year: { $lt: 2000 },\n    genres: \"Short\"\n}).limit(5)\n</code></pre> <p>Obtenemos 5 documentos de cortos de la colecci\u00f3n, posterior al a\u00f1o 2000</p>"},{"location":"mongodb/mongodbdatos/#metodo-sort","title":"M\u00e9todo <code>.sort()</code>","text":"<p>Ordena los documentos devueltos por una consulta.</p> <p>La sintaxis b\u00e1sica es la siguiente:</p> <pre><code>db.collection.find().sort({ campo: orden })\n</code></pre> <ul> <li><code>campo</code>: El nombre del campo por el cual deseas ordenar.</li> <li><code>orden</code>: Puede ser <code>1</code> para orden ascendente o <code>-1</code> para orden descendente.</li> </ul> <p>Por ejemplo, para ordenar por a\u00f1o de lanzamiento de forma ascendente:</p> <pre><code>db.movies.find().sort({ year: 1 })\n</code></pre> <p>Si deseas ordenarlas de forma descendente:</p> <pre><code>db.movies.find().sort({ year: -1 })\n</code></pre> <p>Tambi\u00e9n podemos ordenar por m\u00e1s de un campo. Por ejemplo, para ordenar primero por genre y luego por rating:</p> <pre><code>db.movies.find().sort({ genre: 1, rating: -1 })\n</code></pre> <p>Tambi\u00e9n podemos encadenar estas funciones:</p> <ul> <li>Listado de las 5 mejores pel\u00edculas seg\u00fan la puntuaci\u00f3n \"imdb\"</li> </ul> <pre><code>db.movies.find({}, {\n    title: 1,\n    imdb: 1\n}).sort({ imdb: 1 }).limit(5)\n</code></pre> <p>Mejoramos el resultado anterior y le quitamos los valores vacios en la puntuaci\u00f3n:</p> <pre><code>db.movies.find({ \"imdb.rating\": {\"$ne\": \"\"}}, {\n    title: 1,\n    imdb: 1\n}).sort({ imdb: -1 }).limit(5)\n</code></pre>"},{"location":"mongodb/mongodbdatos/#cursores","title":"Cursores","text":"<p>Al hacer una consulta en el shell se devuelve un cursor. Este cursor lo podemos guardar en un variable, y partir de ah\u00ed trabajar con \u00e9l, como har\u00edamos mediante cualquier lenguaje de programaci\u00f3n. Si <code>cur</code> es la variable que referencia al cursor, podremos utilizar los siguientes m\u00e9todos:</p> M\u00e9todo Uso Lugar de ejecuci\u00f3n <code>cur.hasNext()</code> <code>true/false</code> para saber si quedan elementos Cliente <code>cur.next()</code> Pasa al siguiente documento Cliente <code>cur.limit(cantidad)</code> Restringe el n\u00famero de resultados a <code>cantidad</code> Servidor <code>cur.sort({campo:1})</code> Ordena los datos por campo: <code>1</code> ascendente o <code>-1</code> descendente Servidor <code>cur.skip(cantidad)</code> Permite saltar <code>cantidad</code> elementos con el cursor Servidor <code>cur.count()</code> Obtiene la cantidad de documentos Servidor <p>Como tras realizar una consulta con find realmente se devuelve un cursor, un uso muy habitual es encadenar una operaci\u00f3n de <code>find</code> con <code>sort</code> y/o <code>limit</code> y/o <code>count</code> para ordenar el resultado por uno o m\u00e1s campos y posteriormente limitar el n\u00famero de documentos a devolver o simplemente contar.</p> <p>Estos cursores se utilizan cuando accedemos a consulta desde script en javascript u otros lenguajes.</p> <p>Por ejemplo, a continuacion tenemos c\u00f3digo en javascript que imprime por consola todos los documentos obtenidos tras una consulta</p> javscriptPython <pre><code>// necesario node.js\n// Conectar a la base de datos test\n// const db = connect(\"mongodb://user:pass@localhost:27017/test?authSource=admin\");\nconst db = connect(\"mongodb://localhost:27017/test\");\n\n// Realizar una consulta para encontrar todas (5) las pel\u00edculas\nvar cursor = db.movies.find().limit( 5);\n\n// Iterar sobre los resultados usando un cursor\nwhile (cursor.hasNext()) {\n    printjson(cursor.next());\n}\n</code></pre> <pre><code># necesaria librer\u00eda pymongo: \nfrom pymongo import MongoClient\n\n# Conectar a la base de datos\n# client = MongoClient(\"mongodb://user:pass@localhost:27017/test?authSource=admin\")\nclient = MongoClient(\"mongodb://localhost:27017/\")\n# Utilizamos la base de datos \"text\"\ndb = client.test\n\n# Realizar una consulta para encontrar todas (5) las pel\u00edculas\ncursor = db.movies.find().limit(5)\n\n# Iterar sobre los resultados usando un cursor\nfor document in cursor:\n    print(document)\n</code></pre> <p>Se puede tambi\u00e9n usar m\u00e9todos como <code>limit</code> y <code>skip</code> para controlar la cantidad de resultados:</p> <ul> <li>Ejemplo: obtenemos 5 registros de una coleccc\u00f3n</li> </ul> javscriptPython <pre><code>// necesario node.js\n// Conectar a la base de datos test\n// const db = connect(\"mongodb://user:pass@localhost:27017/test?authSource=admin\");\nconst db = connect(\"mongodb://localhost:27017/test\");\n\n// Obtener las primeras 5 pel\u00edculas\nvar limitedCursor = db.movies.find().limit(5);\n\n// Iterar sobre los resultados limitados\nwhile (limitedCursor.hasNext()) {\n    printjson(limitedCursor.next());\n}\n\n// Saltar las primeras 2 pel\u00edculas y obtener las siguientes 3\nvar paginatedCursor = db.movies.find().skip(2).limit(3);\n\nwhile (paginatedCursor.hasNext()) {\n    printjson(paginatedCursor.next());\n}\n</code></pre> <pre><code># necesaria librer\u00eda pymongo: \nfrom pymongo import MongoClient\n\n# Conectar a la base de datos\n# client = MongoClient(\"mongodb://user:pass@localhost:27017/test?authSource=admin\")\nclient = MongoClient(\"mongodb://localhost:27017/\")\n# Utilizamos la base de datos \"text\"\ndb = client.test\n\n# Obtener las primeras 5 pel\u00edculas\nlimited_cursor = db.movies.find().limit(5)\n\n# Iterar sobre los resultados limitados\nfor document in limited_cursor:\n    print(document)\n\n# Saltar las primeras 2 pel\u00edculas y obtener las siguientes 3\npaginated_cursor = db.movies.find().skip(2).limit(3)\n\n# Iterar sobre los resultados paginados\nfor document in paginated_cursor:\n    print(document)\n</code></pre> <p>En todo caso, estos ejemplos quedan fuera del alcance de nuestro objetivo para este curso. Para m\u00e1s informaci\u00f3n MongoDB Documentation \u2192 MongoDB Drivers \u2192 Node.js</p>"},{"location":"mongodb/mongodbdatos/#agregaciones","title":"Agregaciones","text":"<p>Las agregaciones en MongoDB son una poderosa herramienta que permite procesar y analizar grandes vol\u00famenes de documentos en una colecci\u00f3n. A trav\u00e9s de un proceso conocido como pipeline de agregaci\u00f3n, puedes realizar diversas operaciones en los datos, como filtrar, agrupar, ordenar y transformar documentos. Aqu\u00ed te explico m\u00e1s sobre su funcionamiento y usos:</p> <p>Las agregaciones permiten realizar c\u00e1lculos y transformaciones sobre los datos. En lugar de simplemente recuperar documentos, puedes aplicar funciones que devuelven resultados calculados, como sumas, promedios, conteos, etc. Esto es similar a las consultas SQL que utilizan <code>GROUP BY</code>.</p>"},{"location":"mongodb/mongodbdatos/#usos-y-ventajas-de-las-agregaciones","title":"Usos y ventajas de las agregaciones","text":"<ol> <li>Agrupaci\u00f3n de Datos: Puedes agrupar documentos por un campo espec\u00edfico y realizar c\u00e1lculos sobre esos grupos. Por ejemplo, sumar las ventas por cada vendedor.</li> <li>Filtrado de Datos: Utilizando la etapa <code>$match</code>, puedes filtrar documentos antes de realizar otras operaciones, lo que optimiza el rendimiento.</li> <li>Transformaci\u00f3n de Datos: Puedes remodelar documentos usando la etapa <code>$project</code>, lo que te permite seleccionar y renombrar campos.</li> <li>An\u00e1lisis de Tendencias: Las agregaciones son \u00fatiles para analizar cambios en los datos a lo largo del tiempo, como el crecimiento de ventas mensuales.</li> <li>Operaciones Complejas: Puedes realizar operaciones m\u00e1s complejas, como uniones entre colecciones, utilizando la etapa <code>$lookup</code>.</li> </ol> <p>Las agregaciones son esenciales para obtener <code>insights</code> significativos de tus datos en MongoDB, acotando el rango de los datos sobre los que trabajamos y facilitando el an\u00e1lisis y la toma de decisiones.</p>"},{"location":"mongodb/mongodbdatos/#metodo-aggregate","title":"M\u00e9todo <code>.aggregate()</code>","text":"<p>Para poder agrupar datos y realizar c\u00e1lculos sobre \u00e9stos, MongoDB ofrece diferentes alternativas una de ellas es mediante el m\u00e9todo <code>.aggretate</code></p>"},{"location":"mongodb/mongodbdatos/#pipeline-de-agregacion","title":"Pipeline de agregaci\u00f3n","text":"<p>Las agregaciones usan un pipeline, conocido como Aggregation Pipeline, de ah\u00ed que el m\u00e9todo <code>aggregate</code> use un array con [ ] donde cada elemento es una fase del pipeline, de modo que la salida de una fase es la entrada de la siguiente:</p> <pre><code>db.coleccion.aggregate([op1, op2, ... opN])\n</code></pre> <p>En la siguiente imagen se resumen los pasos de una agrupaci\u00f3n donde primero se eligen los elementos que vamos a agrupar mediante <code>$match</code>, el resultado saliente se agrupan con <code>$group</code>, y sobre los agrupado mediante <code>$sum</code> se calcula el total:</p> Ejemplo de pipeline con <code>$match</code> y <code>$group</code> <p>Al realizar un pipeline dividimos las consultas en fases, donde cada fase utiliza un operador para realizar una transformaci\u00f3n. Aunque no hay l\u00edmite en el n\u00famero de fases en una consulta, es importante destacar que el orden importa, y que hay optimizaciones para ayudar a que el pipeline tenga un mejor rendimiento (por ejemplo, hacer un <code>$match</code> al principio para reducir la cantidad de datos)</p>"},{"location":"mongodb/mongodbdatos/#operadores-del-pipeline","title":"Operadores del pipeline","text":"<p>Antes de nada cabe destacar que las fases se pueden repetir, por lo que una consulta puede repetir operadores para encadenar diferentes acciones.</p> <p>A continuaci\u00f3n vamos a estudiar todos estos operadores:</p> Operador Descripci\u00f3n Cardinalidad <code>$project</code> Proyecci\u00f3n de campos, es decir, propiedades en las que estamos interesados. Tambi\u00e9n nos permite modificar un documento, o crear un subdocumento (reshape) 1:1 <code>$match</code> Filtrado de campos, similar a where N:1 <code>$group</code> Para agrupar los datos, similar a group by N:1 <code>$sort</code> Ordenar 1:1 <code>$skip</code> Saltar N:1 <code>$limit</code> Limitar los resultados N:1 <code>$unwind</code> Separa los datos que hay dentro de un array 1:N <p>Explicaci\u00f3n por tipo</p> Cardinalidad Significado Ejemplo de comportamiento <code>1:1</code> Por cada documento que entra, sale exactamente uno. El documento es modificado, pero no se eliminan ni se duplican. <code>N:1</code> De varios documentos de entrada, se genera uno solo. Ej. agrupaci\u00f3n o filtrado que descarta muchos. <code>1:N</code> De un solo documento, pueden salir varios. Ej. descomposici\u00f3n de arrays con <code>$unwind</code>."},{"location":"mongodb/mongodbdatos/#ejemplos-de-uso","title":"Ejemplos de uso","text":"<p>La fase group agrupa los documentos con el prop\u00f3sito de calcular valores agregados de una colecci\u00f3n de documentos. Por ejemplo, podemos usar <code>$group</code> para calcular la cantidad de peliculas por tipo.</p> <p><pre><code>db.movies.aggregate([\n    { $group: {\n        _id: \"$type\",\n        total: { $sum:1}\n      }\n    }\n])\n</code></pre> Etapas explicadas</p> <ol> <li> <p><code>db.movies.aggregate([...])</code>    Ejecuta una agregaci\u00f3n sobre la colecci\u00f3n <code>movies</code>.</p> </li> <li> <p><code>{ $group: { ... } }</code>    La etapa <code>$group</code> agrupa los documentos por el valor de un campo.</p> </li> <li> <p><code>_id: \"$type\"</code> </p> <ul> <li>Agrupa los documentos por el valor del campo <code>\"type\"</code> (por ejemplo: <code>\"movie\"</code>, <code>\"series\"</code>, etc.).  Cada grupo representar\u00e1 un valor \u00fanico de <code>type</code>. </li> <li>Cuando referenciemos al valor de un campo lo haremos poniendo entre comillas un <code>$</code> delante del nombre del campo.</li> </ul> </li> <li> <p><code>total: { $sum: 1 }</code>      Cuenta cu\u00e1ntos documentos hay en cada grupo.      Cada vez que un documento entra en el grupo, se suma <code>1</code>.</p> </li> </ol> <p>Cuidado!</p> <p>La salida de <code>$group</code> esta desordenada</p> <p>Si lo que queremos es que el valor del identificador contenga un objeto, lo podemos asociar como valor:</p> <pre><code>db.movies.aggregate([\n    { $group: {\n        _id: { \"Tipo\" : \"$type\"},\n        total: { $sum:1}\n      }\n    }\n])\n</code></pre> <p>Tambi\u00e9n podemos agrupar m\u00e1s de un atributo, de tal modo que tengamos un _id compuesto. Por ejemplo:</p> <pre><code>db.movies.aggregate([\n    { $group: {\n        _id: { \n            \"Tipo\" : \"$type\",\n            \"G\u00e9nero\": \"$genres\"},\n        total: { $sum:1}\n      }\n    }\n])\n</code></pre> <p>El operador <code>$sum</code> acumula los valores y devuelve la suma. En los ejemplos anteriores, sumaba 1 por cada elemento contrado, pero podr\u00eda sumar cualquier valor num\u00e9rico. Por ejemplo, calculamos las nominaciones y premios ganados de las peliculas seg\u00fan el tipo:</p> <pre><code>db.movies.aggregate([\n    { $group: {\n        _id: { \"Tipo\" : \"$type\"},\n        Nominaciones: { $sum: \"$awards.nominations\"},\n        Ganadas: { $sum: \"$awards.wins\"}\n\n      }\n    }\n])\n</code></pre> <p>No solo tenemos el operados <code>$sum</code> en la siguiente tabla se indican algunos de los operadores acumuladores m\u00e1s comunes que puedes utilizar en el m\u00e9todo <code>.aggregate</code> de MongoDB:</p> Operador Descripci\u00f3n Ejemplo <code>$sum</code> Suma de valores. <code>{ $group: { _id: null, total: { $sum: \"$cantidad\" } } }</code> <code>$avg</code> Promedio de valores. <code>{ $group: { _id: \"$categoria\", promedio: { $avg: \"$precio\" } } }</code> <code>$min</code> Valor m\u00ednimo. <code>{ $group: { _id: \"$categoria\", minimo: { $min: \"$precio\" } } }</code> <code>$max</code> Valor m\u00e1ximo. <code>{ $group: { _id: \"$categoria\", maximo: { $max: \"$precio\" } } }</code> <code>$push</code> A\u00f1ade valores a un array. <code>{ $group: { _id: \"$categoria\", items: { $push: \"$nombre\" } } }</code> <code>$addToSet</code> A\u00f1ade valores \u00fanicos a un array. <code>{ $group: { _id: \"$categoria\", itemsUnicos: { $addToSet: \"$nombre\" } } }</code> <code>$first</code> Primer valor en el grupo. <code>{ $group: { _id: \"$categoria\", primerValor: { $first: \"$nombre\" } } }</code> <code>$last</code> \u00daltimo valor en el grupo. <code>{ $group: { _id: \"$categoria\", ultimoValor: { $last: \"$nombre\" } } }</code> <code>$stdDevPop</code> Desviaci\u00f3n est\u00e1ndar de la poblaci\u00f3n de los valores. <code>{ $group: { _id: \"$categoria\", desviacion: { $stdDevPop: \"$precio\" } } }</code> <code>$stdDevSamp</code> Desviaci\u00f3n est\u00e1ndar de la muestra de los valores. <code>{ $group: { _id: \"$categoria\", desviacion: { $stdDevSamp: \"$precio\" } } }</code> <p>Estos operadores son muy \u00fatiles para realizar c\u00e1lculos y transformaciones en los datos dentro de un pipeline de agregaci\u00f3n en MongoDB Aggregation Operators</p> <p>Por ejemplo, mediante <code>$avg</code> podemos obtener el promedio de los valores de un campo num\u00e9rico.</p> <ul> <li>Promedio de puntuaci\u00f3n IMDb por a\u00f1o</li> </ul> <pre><code>db.movies.aggregate([\n  { $group: {\n      _id: \"$year\",\n      promedio_rating: { $avg: \"$imdb.rating\" }\n    }\n  }\n])\n</code></pre> <p>El operador <code>$sort</code> ordena los documentos recibidos por el campo, y el orden indicado por la expresi\u00f3n indicada al pipeline. Si queremos ordenar el listado anterior por a\u00f1os de menor a mayor (1):</p> <pre><code>db.movies.aggregate([\n  { $group: {\n      _id: \"$year\",\n      promedio_rating: { $avg: \"$imdb.rating\" }\n    }\n  },\n  { $sort: { _id: 1 } }\n])\n</code></pre> <p>El operador <code>$match</code> se utiliza principalmente para filtrar los documentos que pasar\u00e1n a la siguiente etapa del pipeline o a la salida final. Por ejemplo, queremos s\u00f3lo aquellas puntuaciones anteriores a 2006:</p> <pre><code>db.movies.aggregate([\n  {\n    $match: {\n      released: { $lt: new ISODate('2006-01-01T00:00:00Z') },\n      year: { $type: \"number\" }\n    }\n  },\n  { $group: {\n      _id: \"$year\",\n      promedio_rating: { $avg: \"$imdb.rating\" },\n    }\n  },\n  { $sort: { _id: -1 } }\n])\n</code></pre> <p>Y si queremos que solo contabilice si hay al menos 30 pel\u00edculas:</p> <pre><code>db.movies.aggregate([\n  {\n    $match: {\n      released: { $lt: new ISODate('2006-01-01T00:00:00Z') },\n      year: { $type: \"number\" }\n    }\n  },\n  { $group: {\n      _id: \"$year\",\n      promedio_rating: { $avg: \"$imdb.rating\" },\n      cantidad: { $sum: 1}\n    }\n  },\n  {\n    $match: {\n      cantidad: { $gt: 30 }\n    }\n  },\n  { $sort: { _id: -1 } }\n])\n</code></pre> <p>Otro operador interesante es <code>$unwind</code>, ya permite descomponer un array en multiples documentos. Si quisi\u00e9ramos obtener el n\u00famero medio de votos agrupados por pa\u00edses, podr\u00edamos hacer:</p> <pre><code>db.movies.aggregate([\n  { $unwind: \"$countries\" },\n  { $group: {\n      _id: \"$countries\",\n      promedio_votos: { $avg: \"$imdb.votes\" }\n    }\n  }\n])\n</code></pre> <p>y as\u00ed podr\u00edamos ordenar de mayor a menor por ese mismo n\u00famero de votos:</p> <pre><code>db.movies.aggregate([\n  { $unwind: \"$countries\" },\n  { $group: {\n      _id: \"$countries\",\n      promedio_votos: { $avg: \"$imdb.votes\" }\n    }\n  },\n  { $sort: { promedio_votos: -1 } }\n])\n</code></pre> <p>Si queremos realizar una proyecci\u00f3n sobre el conjunto de resultados y quedarnos con un subconjunto de los campos usaremos el operador <code>$project</code>. Como resultado obtendremos el mismo n\u00famero de documentos, y en el orden indicado en la proyecci\u00f3n.</p> <pre><code>db.movies.aggregate([\n  { $unwind: \"$countries\" },\n  { $group: {\n      _id: \"$countries\",\n      promedio_votos: { $avg: \"$imdb.votes\" }\n    }\n  },\n  { $project: {\n      pais: \"$_id\",\n      _id: 0,\n      promedio_votos: { $round: [\"$promedio_votos\", 2] }\n    }\n  },\n  { $sort: { promedio_votos: -1 } }\n])\n</code></pre> <p>As\u00ed pues, como hemos visto el abanico de posiblidades es muy extenso, aunque en nuestro curso no tenemos tiempo suficiente para profundizar en todas las posibilidades, nos quedamos aqu\u00ed.</p> <p>Para m\u00e1s informaci\u00f3n tienes el Manual de MongoDB: Aggregation Operations</p>"},{"location":"mongodb/mongodbdatos/#bases-de-datos-de-ejemplo","title":"Bases de datos de ejemplo","text":"<ol> <li>Bases de datos que ofrece directamente MongoDB</li> <li>Datos de AirBnB de Valencia: Inside AirBnB</li> </ol>"},{"location":"nosql/consistencia/","title":"Consistencia","text":""},{"location":"nosql/consistencia/#consistencia_1","title":"Consistencia","text":"<p>En un sistema consistente, las escrituras de una aplicaci\u00f3n son visibles en siguientes consultas. Con una consistencia eventual, las escrituras no son visibles inmediatamente.</p> <p>Por ejemplo, en un sistema de control de stock, si el sistema es consistente, cada consulta obtendr\u00e1 el estado real del inventario, mientras que si tiene consistencia eventual, puede que no sea el estado real en un momento concreto pero terminar\u00e1 si\u00e9ndolo en breve.</p> Tipos de consistencia"},{"location":"nosql/consistencia/#sistemas-consistentes","title":"Sistemas consistentes","text":"<p>Cada aplicaci\u00f3n tiene diferentes requisitos para la consistencia de los datos. Para muchas aplicaciones, es imprescindible que los datos sean consistentes en todo momento. Como los equipos de desarrollo han estado trabajo con un modelo de datos relacional durante d\u00e9cadas, este enfoque parece natural. Sin embargo, en otras ocasiones, la consistencia eventual es un traspi\u00e9s aceptable si conlleva una mayor flexibilidad en la disponibilidad del sistema.</p> <p>Las bases de datos documentales y de grafos pueden ser consistentes o eventualmente consistentes. Por ejemplo, MongoDB ofrece un consistencia configurable. De manera predeterminada, los datos son consistentes, de modo que todas las escrituras y lecturas se realizan sobre la copia principal de los datos. Pero como opci\u00f3n, las consultas de lectura, se pueden realizar con las copias secundarias donde los datos tendr\u00e1n consistencia eventual. La elecci\u00f3n de la consistencia se realiza a nivel de consulta.</p>"},{"location":"nosql/consistencia/#sistemas-de-consistencia-eventual","title":"Sistemas de consistencia eventual","text":"<p>Con los sistemas eventualmente consistentes, hay un per\u00edodo de tiempo en el que todas las copias de los datos no est\u00e1n sincronizados. Esto puede ser aceptable para aplicaciones de s\u00f3lo-lectura y almacenes de datos que no cambian frecuentemente, como los archivos hist\u00f3ricos. Dentro del mismo saco podemos meter las aplicaciones con alta tasa de escritura donde las lecturas sean poco frecuentes, como un archivo de log.</p> <p>Un claro ejemplo de sistema eventualmente consistente es el servicio DNS, donde tras registrar un dominio, puede tardar varios d\u00edas en propagar los datos a trav\u00e9s de Internet, pero siempre est\u00e1n disponibles aunque contenga una versi\u00f3n antigua de los datos.</p> <p>Respecto a las bases de datos NoSQL, los almacenes de clave-valor y los basados en columnas son sistemas eventualmente consistentes. Estos tienen que soportar conflictos en las actualizaciones de registros individuales.</p> <p>Como las escrituras se pueden aplicar a cualquier copia de los datos, puede ocurrir, y no ser\u00eda muy extra\u00f1o, que hubiese un conflicto de escritura.</p> <p>Algunos sistemas como Riak utilizan vectores de reloj para determinar el orden de los eventos y asegurar que la operaci\u00f3n m\u00e1s reciente gana en caso de un conflicto.</p> <p>Otros sistemas como CouchDB, retienen todos los valores conflictivos y permiten al usuario resolver el conflicto. Otro enfoque seguido por Cassandra sencillamente asume que el valor m\u00e1s grande es el correcto.</p> <p>Por estos motivos, las escrituras tienden a comportarse bien en sistemas eventualmente consistentes, pero las actualizaciones pueden conllevar sacrificios que complican la aplicaci\u00f3n.</p>"},{"location":"nosql/consistencia/#teorema-cap","title":"Teorema CAP","text":"<p>Propuesto por Eric Brewer en el a\u00f1o 2000, prueba que podemos crear una base de datos distribuida que elija dos de las siguientes tres caracter\u00edsticas:</p> <ul> <li>Consistencia: las escrituras son at\u00f3micas y todas las peticiones posteriores obtienen el nuevo valor, independientemente del lugar de la petici\u00f3n.</li> <li>Disponibilidad (Available): la base de datos devolver\u00e1 siempre un valor. En la pr\u00e1ctica significa que no hay downtime.</li> <li>Tolerancia a Particiones: el sistema funcionar\u00e1 incluso si la comunicaci\u00f3n con un servidor se interrumpe de manera temporal (para ello, ha de dividir los datos entre diferentes nodos). Es decir, implica que se pueden recibir lecturas desde unos nodos que no contienen informaci\u00f3n escrita en otros.</li> </ul> <p>En otras palabras, podemos crear un sistema de base de datos que sea consistente y tolerante a particiones (CP), un sistema que sea disponible y tolerante a particiones (AP), o un sistema que sea consistente y disponible (CA). Pero no es posible crear una base de datos distribuida que sea consistente, disponible y tolerante a particiones al mismo tiempo.</p> Teorema CAP <p>El teorema CAP es \u00fatil cuando consideramos el sistema de base de datos que necesitamos, ya que nos permite decidir cual de las tres caracter\u00edsticas vamos a descartar. La elecci\u00f3n realmente se centra entre la disponibilidad y la consistencia, ya que la tolerancia a particiones es una decisi\u00f3n de arquitectura (sea o no distribuida).</p> <p>Aunque el teorema dicte que si en un sistema distribuido elegimos disponibilidad no podemos tener consistencia, todav\u00eda podemos obtener consistencia eventual. Es decir, cada nodo siempre estar\u00e1 disponible para servir peticiones, aunque estos nodos no puedan asegurar que la informaci\u00f3n que contienen sea consistente (pero si bastante precisa), en alg\u00fan momento lo ser\u00e1.</p> <p>Algunas bases de datos tolerantes a particiones se pueden ajustar para ser m\u00e1s o menos consistentes o disponible a nivel de petici\u00f3n. Por ejemplo, Riak trabaja de esta manera, permitiendo a los clientes decidir en tiempo de petici\u00f3n qu\u00e9 nivel de consistencia necesitan.</p>"},{"location":"nosql/consistencia/#clasificacion-segun-cap","title":"Clasificaci\u00f3n seg\u00fan CAP","text":"<p>El siguiente gr\u00e1fico muestra c\u00f3mo dependiendo de estos atributos podemos clasificar los sistemas NoSQL:</p> Clasificaci\u00f3n seg\u00fan CAP <p>As\u00ed pues, las bases de datos NoSQL se clasifican en:</p> <ul> <li>CP: Consistente y tolerantes a particiones. Tanto MongoDB como HBase son CP, ya que dentro de una partici\u00f3n pueden no estar disponibles para responder una determinada consulta (por ejemplo, evitando lecturas en los nodos secundarios), aunque son tolerantes a fallos porque cualquier nodo secundario se puede convertir en principal y asumir el rol del nodo ca\u00eddo.</li> <li>AP: Disponibles y tolerantes a particiones. DynamoDB permite replicar los datos entre sus nodos aunque no garantiza la consistencia en ninguno de los sus servidores.</li> <li>CA: Consistentes y disponible. Aqu\u00ed es donde situar\u00edamos a los SGDB relacionales. Por ejemplo, PostreSQL es CA (aunque ofrece un producto complementario para dar soporte al particionado, como PgCluster), ya que no distribuyen los datos y por tanto la partici\u00f3n no es una restricci\u00f3n. Lo bueno es que la gran mayor\u00eda de sistemas permiten configurarse para cambiar su tipo CAP, lo que permite que MongoDB pase de CP a AP, o CouchDB de AP a CP.</li> </ul>"},{"location":"nosql/consistencia/#base","title":"BASE","text":"<p>De forma an\u00e1loga al modelo transaccional ACID para las bases de datos relacionales que dan soporte a la transaccionalidad ofreciendo en todo momento un sistema consistente, las bases de datos distribuidas siguen el modelo transaccional BASE, el cual se centra en la alta disponibilidad y significa:</p> <ul> <li>B\u00e1sicamente disponible (Basically Available): la base de datos siempre responde a las solicitudes recibidas, ya sea con una respuesta exitosa o con un error, a\u00fan en el caso de que el sistema soporte la tolerancia a particiones (de manera que caiga alg\u00fan nodo o no est\u00e9 accesible por problemas de la red). Esto puedo implicar lecturas desde nodos que no han recibido la \u00faltima escritura, por lo que el resultado puede no ser consistente.</li> <li>Estado blando (Soft State): la base de datos puede encontrarse en un estado inconsistente cuando se produce una lectura, de modo que es posible realizar dos veces la misma lectura y obtener dos resultados distintos a pesar de que no haya habido ninguna escritura entre ambas operaciones, sino que la escritura se hab\u00eda realizado antes en el tiempo y no se hab\u00eda persistido hasta dicho momento.</li> <li>Consistencia eventual (Eventual consistency): tras cada escritura, la consistencia de la base de datos s\u00f3lo se alcanza una vez el cambio ha sido propagado a todos los nodos. Durante el tiempo que tarda en producirse la consistencia, observamos un estado blando de la base de datos.</li> </ul> <p>Una base de datos que sigue el modelo transaccional BASE prefiere la disponibilidad antes que la consistencia (es decir, desde el punto de vista del teorema CAP es AP).</p> <p>Un sistema NoSQL...</p> <p>Una vez vistos todos los conceptos, podemos resumir que un sistema NoSQL es open source, no relacional, sin esquema predefinido, con escalado horizontal y con un sistema transaccional BASE.</p>"},{"location":"nosql/moddatos/","title":"Modelos de datos","text":"<p>La principal clasificaci\u00f3n de los sistemas de bases de datos NoSQL se realiza respecto a los diferentes modelos de datos:</p>"},{"location":"nosql/moddatos/#documental","title":"Documental","text":"<p>Mientras las bases de datos relacionales almacenan los datos en filas y columnas, las bases de datos documentales emplean documentos. Estos documentos utilizan una estructura JSON, ofreciendo un modo natural e intuitivo para modelar datos de manera similar a la orientaci\u00f3n a objetos, donde cada documento es un objeto.</p> Representaci\u00f3n de un documento <p>Los documentos se agrupan en colecciones o bases de datos, dependiendo del sistema, lo que permite agrupar documentos.</p> <p>Los documentos contienen uno o m\u00e1s campos, donde cada campo contiene un valor con un tipo, ya sea cadena, entero, flotante, fecha, binario o array u otro documento. En vez de extender los datos entre m\u00faltiples columnas y tablas, cada registro y sus datos asociados se almacenan de manera unida en un \u00fanico documento. Esto simplifica el acceso a los datos y reduce (y en ocasiones elimina) la necesidad de joins y transacciones complejas.</p> <p>Dicho de otra manera, en las bases de datos documentales, los datos que van juntos y se emplean juntos, se almacenan juntos.</p>"},{"location":"nosql/moddatos/#caracteristicas","title":"Caracter\u00edsticas","text":"<p>En una base de datos documental, la noci\u00f3n de esquema es din\u00e1mico: cada documento puede contener diferentes campos. Esta flexibilidad puede ser \u00fatil para modelar datos desestructurados y polim\u00f3rficos, lo que facilita la evoluci\u00f3n del desarrollo al permitir a\u00f1adir nuevos campos de manera din\u00e1mica.</p> <p>Perfectamente podemos tener dos documentos que pertenecen a la misma colecci\u00f3n, pero con atributos diferentes. Por ejemplo, un primer documento puede ser el siguiente: <pre><code>{   \n    \"_id\": \"BW001\",   \n    \"nombre\": \"Bruce\",   \n    \"apellido\": \"Wayne\",   \n    \"edad\": 35,   \n    \"salario\": 10000000 \n}\n</code></pre> Mientras que un segundo documento dentro de la misma colecci\u00f3n podr\u00eda ser:</p> <p><pre><code>{\n  \"_id\": \"JK1\",\n  \"nombre\": \"Joker\",\n  \"edad\": 34,\n  \"salario\": 5000000,\n  \"direccion\": {               \n    \"calle\": \"Asilo Arkham\",\n    \"ciudad\": \"Gotham\"\n  },\n  \"proyectos\": [               \n    \"desintoxicacion-virus\",\n    \"top-secret-007\"\n  ]\n}\n</code></pre> Normalmente, cada documento contiene un elemento clave, sobre el cual se puede obtener un documento de manera un\u00edvoca. De todos modos, las bases de datos documentales ofrecen un completo mecanismo de consultas, posibilitando obtener informaci\u00f3n por cualquier campo del documento. Algunos productos ofrecen opciones de indexado para optimizar las consultas, como pueden ser \u00edndices compuestos, dispersos, con tiempo de vida (TTL), \u00fanicos, de texto o geoespaciales.</p> <p>Adem\u00e1s, estos sistemas ofrecen productos que permiten analizar los datos, mediante funciones de agregaci\u00f3n o implementaci\u00f3n de MapReduce.</p> <p>Respecto a la modificaciones, los documentos se pueden actualizar en una \u00fanica sentencia, sin necesidad de dar rodeos para elegir los datos a modificar.</p>"},{"location":"nosql/moddatos/#casos-de-uso","title":"Casos de uso","text":"<p>Las bases de datos documentales se pueden emplear como sistemas de prop\u00f3sito general, v\u00e1lidos para un amplio abanico de aplicaciones gracias a la flexibilidad que ofrece el modelo de datos, lo que permite consultar cualquier campo y modelar de manera natural con un enfoque similar a la programaci\u00f3n orientada a objetos.</p> <p>Entre los casos de \u00e9xito de estos sistemas cabe destacar:</p> <ul> <li>Sistemas de flujo de eventos: entre diferentes aplicaciones dentro de una empresa.</li> <li>Gestores de contenido, plataformas de Blogging: al almacenar los documentos mediante JSON, facilita la estructura de datos para guardar los comentarios, registros de usuarios, etc\u2026\u200b</li> <li>Anal\u00edticas web, datos en tiempo real: al permitir modificar partes de un documento, e insertar nuevos atributos a un documento cuando se necesita una nueva m\u00e9trica.</li> <li>Aplicaciones eCommerce: conforme las aplicaciones crecen, el esquema tambi\u00e9n lo hace.</li> </ul> <p>Si nos centramos en aquellos casos donde no conviene este tipo de sistemas podemos destacar:</p> <ul> <li>Sistemas operacionales con transacciones complejas.</li> <li>Sistemas con consultas agregadas que modifican su estructura. Si los criterios de las consultas no paran de cambiar, acabaremos normalizando los datos.</li> </ul> <p>Los productos m\u00e1s destacados son:</p> <ul> <li>MongoDB: http://www.mongodb.com. Esta base de datos la vamos a estudiar en profundidad en esta unidad de trabajo.</li> <li>CouchDB: http://couchdb.apache.org</li> </ul>"},{"location":"nosql/moddatos/#clave-valor","title":"Clave-Valor","text":"<p>Un almac\u00e9n clave-valor es una simple tabla hash donde todos los accesos a la base de datos se realizan a trav\u00e9s de la clave primaria.</p> <p>Desde una perspectiva de modelo de datos, los almacenes de clave-valor son los m\u00e1s b\u00e1sicos.</p> <p>Su funcionamiento es similar a tener una tabla relacional con dos columnas, por ejemplo <code>id</code> y <code>nombre</code>, siendo <code>id</code> la columna utilizada como clave y <code>nombre</code> como valor. Mientras que en una base de datos relacional en el campo nombre s\u00f3lo podemos almacenar datos de tipo cadena o num\u00e9rico, en un almac\u00e9n clave-valor, el valor puede ser de un dato simple o un objeto. En muchos casos, se almacena un objeto binario BLOB (Binary Large Object). Cuando una aplicaci\u00f3n accede mediante la clave y el valor, se almacenan el par de elementos. Si la clave ya existe, el valor se modifica.</p> Representaci\u00f3n de un almac\u00e9n clave-valor <p>El cliente puede tanto obtener el valor por la clave, asignar un valor a una clave o eliminar una clave del almac\u00e9n. El valor, sin embargo, es opaco al sistema, el cual no sabe que hay dentro de \u00e9l, ya que los datos s\u00f3lo se pueden consultar por la clave, lo cual puede ser un inconveniente. As\u00ed pues, la aplicaci\u00f3n es responsable de saber qu\u00e9 hay almacenado en cada valor.</p> <p>Por ejemplo, Riak utiliza el concepto de bucket (cubo) como una manera de agrupar claves, de manera similar a una tabla.</p> <p>Por ejemplo, Riak permite interactuar con la base de datos mediante peticiones HTTP:</p> <p><pre><code>curl -v -X PUT &lt;http://localhost:8091/riak/heroes/ace&gt; -H \"Content-Type: application/json\" -d {\"nombre\" : \"Batman\", \"color\" : \"Negro\"}\n</code></pre> Algunos almacenes clave-valor, como puede ser Redis, permiten almacenar datos con cualquier estructura, como por ejemplos listas, conjuntos, hashes, permitiendo realizar operaciones como la intersecci\u00f3n, uni\u00f3n, diferencia y rango.</p> RedisPython <pre><code>SET nombre \"Bruce Wayne\"      // String\nHSET heroe nombre \"Batman\"    // Hash \u2013 set\nHSET heroe color \"Negro\"\nSADD \"heroe:amigos\" \"Robin\" \"Alfred\"   // Set \u2013 create/update\n</code></pre> <pre><code>import redis\nr = redis.Redis()\nr.mset({\"Croatia\": \"Zagreb\", \"Bahamas\": \"Nassau\"})\nr.get(\"Bahamas\")\n# b'Nassau'\n</code></pre> <p>Estas prestaciones hacen que Redis se extrapole a \u00e1mbitos ajenos a un almac\u00e9n clave-valor. Otra caracter\u00edstica que ofrecen algunos almacenes es que permiten crear un segundo nivel de consulta o incluso definir m\u00e1s de una clave para un mismo objeto.</p> <p>Como los almacenes clave-valor siempre utilizan accesos por clave primaria, de manera general tienen un gran rendimiento y son f\u00e1cilmente escalables.</p> <p>Si queremos que su rendimiento sea m\u00e1ximo, pueden configurarse para que mantengan la informaci\u00f3n en memoria y que se serialice de manera peri\u00f3dica, a costa de tener una consistencia eventual de los datos.</p>"},{"location":"nosql/moddatos/#diferencias-entre-modelo-documental-y-clave-valor","title":"Diferencias entre modelo Documental y Clave-Valor","text":"<p>Los modelos de datos Documental y Clave-Valor son dos paradigmas comunes en las bases de datos NoSQL. Pueden parecer similares pero existen unas diferencias claras entre ellos:</p> <ul> <li> <p>Estructura de datos: En el modelo documental, los datos se organizan en documentos con una estructura interna, mientras que en el modelo clave-valor, los datos se almacenan como pares de clave-valor simples sin una estructura interna definida.</p> </li> <li> <p>Flexibilidad: El modelo documental ofrece m\u00e1s flexibilidad para almacenar datos semiestructurados o no estructurados, mientras que el modelo clave-valor es m\u00e1s adecuado para datos simples y bien definidos.</p> </li> <li> <p>Consultas: El modelo documental permite consultas m\u00e1s complejas y flexibles utilizando \u00edndices secundarios y lenguajes de consulta avanzados, mientras que en el modelo clave-valor, la recuperaci\u00f3n de datos se realiza principalmente mediante b\u00fasquedas directas por clave.</p> </li> </ul>"},{"location":"nosql/moddatos/#casos-de-uso_1","title":"Casos de uso","text":"<p>Este modelo es muy \u00fatil para representar datos desestructurados o polim\u00f3rficos, ya que no fuerzan ning\u00fan esquema m\u00e1s all\u00e1 de los pares de clave-valor.</p> <p>Entre los casos de uso de estos almacenes podemos destacar el almacenaje de:</p> <ul> <li>Informaci\u00f3n sobre la sesi\u00f3n de navegaci\u00f3n (sessionid)</li> <li>Perfiles de usuario, preferencias</li> <li>Datos del carrito de la compra</li> <li>Cachear datos</li> </ul> <p>Todas estas operaciones van a asociada a operaciones de recuperaci\u00f3n, modificaci\u00f3n o inserci\u00f3n de los datos de una sola vez, de ah\u00ed su elecci\u00f3n.</p> <p>En cambio, no conviene utilizar estos almacenes cuando queremos realizar:</p> <ul> <li>Relaciones entre datos</li> <li>Transacciones entre varias operaciones</li> <li>Consultas por los datos del valor</li> <li>Operaciones con conjuntos de claves</li> </ul> <p>Los almacenes m\u00e1s empleados son:</p> <ul> <li>Riak: https://riak.com</li> <li>Redis: http://redis.io</li> <li>AWS DynamoDB: http://aws.amazon.com/dynamodb</li> <li>Voldemort: http://www.project-voldemort.com/voldemort implementaci\u00f3n open-source de Amazon DynamoDB</li> </ul>"},{"location":"nosql/moddatos/#basado-en-columnas","title":"Basado en columnas","text":"<p>Las bases de datos relacionales utilizan la fila como unidad de almacenamiento, lo que permite un buen rendimiento de escritura. Sin embargo, cuando las escrituras son ocasionales y es m\u00e1s com\u00fan tener que leer unas pocas columnas de muchas filas a la vez, es mejor utilizar como unidad de almacenamiento un grupos de columnas. Es decir, lo que hacemos es girar el modelo 90 grados, de manera que los registros se almacenan en columnas en vez de hacerlo por filas.</p> <p>Supongamos que tenemos los siguientes datos:</p> Ejemplo de una tabla <p>Dependiendo del almacenamiento en filas o columnas tendr\u00edamos la siguiente representaci\u00f3n:</p> Comparaci\u00f3n filas/columnas <p>En un formato columnar los datos del mismo tipo se agrupan, lo que permite codificarlos/comprimirlos, lo que mejora el rendimiento de acceso y reduce el tama\u00f1o:</p> Comparaci\u00f3n filas/columnas Columnar por filasColumnar por columnas <pre><code>{ \n\"Fila 1\": [1, \"US\", \"Free\"],\n\"Fila 2\": [2, \"UK\", \"Paid\"],\n\"Fila 3\": [3, \"ES\", \"Paid\"]\n}\n</code></pre> <pre><code>{ \n\"user_id\": [1, 2, 3],\n\"country\": [\"US\", \"UK\", \"ES\"],\n\"subscription_type\": [\"Free\", \"Paid\", \"Paid\"]\n}\n</code></pre> <p>Autoevaluaci\u00f3n</p> <p>Si tenemos que a\u00f1adir un nuevo registro \u00bfQu\u00e9 modelo ser\u00e1 m\u00e1s eficiente?</p> <p>Sin embargo, a medida que se incrementa la utilizaci\u00f3n de an\u00e1lisis de datos en memoria, con soluciones como Spark, los beneficios relativos de la base de datos columnares comparados con los de las bases de datos orientadas a filas pueden llegar a ser menos importantes.</p>"},{"location":"nosql/moddatos/#representacion","title":"Representaci\u00f3n","text":"<p>Un modelo basado en columnas se representa como una estructura agregada de dos niveles. El primer nivel formado por un almac\u00e9n clave-valor, siendo la clave el identificador de la fila, y el valor un nuevo mapa con los datos agregados de la fila (familias de columnas). Los valores de este segundo nivel son las columnas. De este modo, podemos acceder a los datos de un fila, o a una determinada columna:</p> Representaci\u00f3n de un almac\u00e9n basado en columnas <p>BigTable</p> <p>Los modelos de datos basados en columnas se basan en la implementaci\u00f3n de Google de la tecnolog\u00eda BigTable http://research.google.com/archive/bigtable.html, la cual consiste en columnas separadas y sin esquema, a modo de mapa de dos niveles.</p> <p>As\u00ed pues, los almacenes basados en columnas utilizan un mapa ordenado multi-dimensional y distribuido para almacenar los datos. Est\u00e1n pensados para que cada fila tenga una gran n\u00famero de columnas (del orden del mill\u00f3n), almacenando las diferentes versiones que tenga una fila (pudiendo almacenar del orden de miles de millones de filas).</p>"},{"location":"nosql/moddatos/#familias-de-columnas","title":"Familias de columnas","text":"<p>Una columna consiste en un pareja <code>name-value</code>, donde el nombre hace de clave. Adem\u00e1s, contiene un atributo timestamp para poder expirar datos y resolver conflictos de escritura.</p> <p>Un ejemplo de columna podr\u00eda ser: <pre><code>{\n  name: \"nombre\",\n  value: \"Bruce\",\n  timestamp: 12345667890\n}\n</code></pre> Una fila es una colecci\u00f3n de columnas agrupadas a una clave. <pre><code>{\n    {         \n        name: \"nombre\",         \n        value: \"Bruce\",         \n        timestamp: 12345667890     \n    },     \n    {         \n        name: \"nombre\",         \n        value: \"Clark\",         \n        timestamp: 12345667891     \n    },     \n    {         \n        name: \"nombre\",         \n        value: \"Barbara\",         \n        timestamp: 12345667892     \n    } \n}\n</code></pre> Si agrupamos filas similares tendremos una familia de columnas (similar al concepto de tabla): <pre><code>// familia de columnas\n{\n  // fila\n  \"tim-gordon\" : {\n    nombre: \"Tim\",\n    apellido: \"Gordon\",\n    ultimaVisita: \"2015/12/12\"\n  }\n  // fila\n  \"bruce-wayne\" : {\n    nombre: \"Bruce\",\n    apellido: \"Wayne\",\n    lugar: \"Gotham\"\n  }\n}\n</code></pre> Con este ejemplo, podemos ver como las diferentes filas de la misma tabla (familia de columnas) no tienen por que compartir el mismo conjunto de columnas. Adem\u00e1s, las columnas se pueden anidar dentro de otras formando super-columnas, donde el valor es un nuevo mapa de columnas.</p> <p><pre><code>{\n    name: \"libro:978-84-16152-08-7\",   \n    value: \n    {     \n        autor: \"Grant Morrison\",     \n        titulo: \"Batman - Asilo Arkham\",     \n        isbn: \"978-84-16152-08-7\"   \n    } \n}\n</code></pre> Cuando se utilizan super columnas para crear familias de columnas tendremos una familia de super columnas.</p> <p>En resumen, las bases de datos basadas en columnas, almacenan los datos en familias de columnas como filas, las cuales tienen muchas columnas asociadas al identificador de una fila. Las familias de columnas son grupos de datos relacionados, a las cuales normalmente se accede de manera conjunta.</p>"},{"location":"nosql/moddatos/#operaciones","title":"Operaciones","text":"<p>A la hora de consultar los datos, \u00e9stos se pueden obtener por la clave primaria de la familia. As\u00ed pues, podemos obtener toda una familia, o la columna de una familia:</p> <pre><code>// Mediante Cassandra\nGET Clientes['bruce-wayne'];  // familia\nGET Clientes['bruce-wayne']['lugar']; // columna\n</code></pre> <p>Algunos productos ofrecen un soporte limitado para \u00edndices secundarios, pero con restricciones. Por ejemplo, Cassandra ofrece el lenguaje CQL similar a SQL pero sin joins, ni subconsultas donde las restricciones de where son sencillas:</p> <p><pre><code>SELECT * FROM Clientes\nSELECT nombre,email FROM Clientes\nSELECT nombre,email FROM Clientes WHERE lugar='Gotham'\n</code></pre> Las actualizaciones se realizan en dos pasos: primero encontrar el registro y segundo modificarlo. En estos sistemas, una modificaci\u00f3n puede suponer una reescritura completa del registro independientemente que hayan cambiado unos pocos bytes del mismo.</p>"},{"location":"nosql/moddatos/#casos-de-uso_2","title":"Casos de uso","text":"<p>Las bases de datos columnares se han empleado durante d\u00e9cadas ofreciendo beneficios a las aplicaciones de negocio modernas, como la anal\u00edtica de datos, business intelligence y data warehousing.</p> <p>Son multiprop\u00f3sito, aunque su uso se centra en el mercado del big data, la anal\u00edtica de datos, cubos multidimensionales OLAP y/o almacenar metadatos y realizar anal\u00edtica en tiempo real.</p> <p>Adem\u00e1s de poder comprimir los datos, los datos est\u00e1n auto-indexados, lo que implica que utiliza menos espacio en disco, y acelera la ejecuci\u00f3n de consultas agregadas entre m\u00faltiples tablas que implica el uso de joins.</p> <p>En cambio, no se recomienda su uso en aplicaciones de procesamiento transaccional (OLTP), ya que las bases de datos relacionales gestionan mejor el procesamiento concurrente y el aislamiento de las operaciones.</p> <p>Los productos m\u00e1s destacados son:</p> <ul> <li>HBase : http://hbase.apache.org, el cual se basa en Hadoop</li> <li>Cassandra : http://cassandra.apache.org</li> <li>Amazon Redshift: https://aws.amazon.com/es/redshift/</li> </ul>"},{"location":"nosql/moddatos/#grafos","title":"Grafos","text":"<p>Las bases de datos de grafos almacenan entidades y las relaciones entre estas entidades. Las entidades se conocen como nodos, los cuales tienen propiedades. Cada nodo es similar a una instancia de un objeto. Las relaciones, tambi\u00e9n conocidas como v\u00e9rtices, a su vez tienen propiedades, y su sentido es importante.</p> Representaci\u00f3n de un grafo <p>Los nodos se organizan mediante relaciones que facilitan encontrar patrones de informaci\u00f3n existente entre los nodos. Este tipo de organizaci\u00f3n permite almacenar los datos una vez e interpretar los datos de diferentes maneras dependiendo de sus relaciones.</p> <ul> <li>Los nodos son entidades que tienen propiedades, tales como el nombre. Por ejemplo, en el gr\u00e1fico cada nodo tiene una propiedad <code>name</code>. </li> <li>Tambi\u00e9n podemos ver que las relaciones tienen tipos, como <code>label</code>, <code>since</code>, etc\u2026\u200b </li> <li>Estas propiedades permiten organizar los nodos. Las relaciones pueden tener m\u00faltiples propiedades, y adem\u00e1s tienen direcci\u00f3n, con lo cual si queremos incluir bidireccionalidad tenemos que a\u00f1adir dos relaciones en sentidos opuestos. </li> <li>Tanto los nodos como las relaciones tienen un atributo <code>id</code> que los identifica.</li> </ul> <p>Por ejemplo, podemos comenzar a crear el grafo anterior mediante Neo4J de la siguiente manera:</p> <p><pre><code>Node alice = graphDb.createNode();\nalice.setProperty(\"name\", \"Alice\");\nNode bob = graphDb.createNode();\nbob.setProperty(\"name\", \"Bob\");\n\nalice.createRelationshipTo(bob, FRIEND);\nbob.createRelationshipTo(alice, FRIEND);\n</code></pre> Los nodos permiten tener diferentes tipos de relaciones entre ellos y as\u00ed representar relaciones entre las entidades del dominio, y tener relaciones secundarias para caracter\u00edsticas como categor\u00eda, camino, \u00e1rboles de tiempo, listas enlazas para acceso ordenado, etc\u2026\u200b Al no existir un l\u00edmite en el n\u00famero ni en el tipo de relaciones que puede tener un nodo, todas se pueden representar en la misma base de datos.</p>"},{"location":"nosql/moddatos/#traversing","title":"Traversing","text":"<p>Una vez tenemos creado un grafo de nodos y relaciones, podemos consultar el grafo de muchas maneras; por ejemplo \"obtener todos los nodos que son miembros del grupo de ajedrez y que tienen m\u00e1s de 20 a\u00f1os\". Realizar una consulta se conoce como hacer un traversing (recorrido) del mismo.</p> <p>Un ejemplo de traversing mediante Neo4J ser\u00eda:</p> <pre><code>Node ajedrez = nodeIndex.get(\"name\", \"chess\").getSingle();\nallRelationships = ajedrez.getRelationships(Direction.INCOMING);\n</code></pre> <p>Una ventaja a destacar de las bases de datos basadas en grafos es que podemos cambiar los requisitos de traversing sin tener que cambiar los nodos o sus relaciones.</p> <p>En las bases de datos de grafos, recorrer las relaciones es muy r\u00e1pido, ya que no se calculan en tiempo de consulta, sino que se persisten como una relaci\u00f3n, y por tanto no hay que hacer ning\u00fan c\u00e1lculo.</p> <p>En cambio, en una base de datos relacional, para crear una estructura de grafo se realiza para una relaci\u00f3n sencilla (\u00bfQuien es mi jefe?\"). Para poder a\u00f1adir otras relaciones necesitamos muchos cambios en el esquema y trasladar datos entre tablas. Adem\u00e1s, necesitamos de antemano saber qu\u00e9 consultas queremos realizar para modelar las tablas y las relaciones acorde a las consultas.</p> <p>As\u00ed pues, estos sistemas ofrecen modelos ricos de consultas donde se pueden investigar las relaciones simples y complejas entre los nodos para obtener informaci\u00f3n directa e indirecta de los datos del sistemas. Los tipos de an\u00e1lisis que se realizan sobre estos sistema se ci\u00f1en a los tipos de relaci\u00f3n existente entre los datos.</p>"},{"location":"nosql/moddatos/#casos-de-uso_3","title":"Casos de uso","text":"<p>Mientras que el modelo de grafos no es muy intuitivo y tiene una importante curva de aprendizaje, se puede usar en un gran n\u00famero de aplicaciones.</p> <p>Su principal atractivo es que facilitan almacenar las relaciones entre entidades de una aplicaci\u00f3n, como por ejemplo en una red social, o las intersecciones existentes entre carreteras. Es decir, se emplean para almacenar datos que se representan como nodos interconectados.</p> <p>Por lo tanto, los casos de uso son:</p> <ul> <li>Datos conectados: redes sociales con diferentes tipos de conexiones entre los usuarios.</li> <li>Enrutamiento, entrega o servicios basados en la posici\u00f3n: si las relaciones almacenan la distancia entre los nodos, podemos realizar consultas sobre lugares cercanos, trayecto m\u00e1s corto, etc\u2026\u200b</li> <li>Motores de recomendaciones: de compras, de lugares visitados, etc\u2026\u200b En cambio, no se recomienda su uso cuando necesitemos modificar todos o un subconjunto de entidades, ya que modificar una propiedad en todos los nodos es una operaci\u00f3n compleja.</li> </ul> <p>Los productos m\u00e1s destacados son:</p> <ul> <li>Neo4j: http://neo4j.com</li> <li>ArangoDB: https://www.arangodb.com/</li> <li>Apache TinkerPop: https://tinkerpop.apache.org/</li> <li>Amazon Neptune: https://aws.amazon.com/es/neptune/</li> </ul>"},{"location":"nosql/moddatos/#tabla-comparativa","title":"Tabla comparativa","text":"Diferencias entre modelos Documental Clave-Valor Basado en Columnas Grafos Estructura de Datos Documentos JSON/BSON/XML Pares de Clave-Valor Columnas con familias Nodos y Relaciones Flexibilidad Flexible Variable Menos flexible Variable Consultas Complejas, con \u00edndices y lenguaje de consulta avanzado B\u00fasquedas directas por clave Consultas ad-hoc limitadas Consultas complejas de relaciones Escalabilidad Escalabilidad Horizontal Escalabilidad Horizontal Escalabilidad Horizontal Escalabilidad Horizontal y Vertical Transacciones Transacciones ACID Operaciones at\u00f3micas simples Transacciones ACID Transacciones ACID Ejemplos MongoDB, Couchbase Redis, DynamoDB Cassandra, HBase Neo4j, Amazon Neptune"},{"location":"nosql/moddatos/#actividades-propuestas","title":"\ud83d\udcdd Actividades propuestas","text":"<p>Actividades</p> <ol> <li>Asignar modelo de datos a escenarios:  <ul> <li>Wiki de c\u00f3mics  </li> <li>Informaci\u00f3n acad\u00e9mica de un pa\u00eds  </li> </ul> </li> <li>Investigar persistencia pol\u00edglota </li> <li>Clasificar: BigTable, Cassandra, CouchDB, DynamoDB, HBase, MongoDB, Redis, Riak, Voldemort.</li> </ol>"},{"location":"nosql/nosql/","title":"Almacenamiento de datos. NoSQL","text":""},{"location":"nosql/nosql/#almacenamiento-de-datos","title":"Almacenamiento de datos","text":"<p>Se puede decir que estamos en la tercera plataforma del almacenamiento de datos. La primera lleg\u00f3 con los primeros computadores y se materializ\u00f3 en las bases de datos jer\u00e1rquicas y en red, as\u00ed como en el almacenamiento ISAM. La segunda vino de la mano de Internet y las arquitecturas cliente-servidor, lo que dio lugar a las bases de datos relacionales.</p> <p>La tercera se ve motivada por el Big Data, los dispositivos m\u00f3viles, las arquitecturas cloud, las redes de IoT y las tecnolog\u00edas/redes sociales. Es tal el volumen de datos que se genera que aparecen nuevos paradigmas como NoSQL, NewSQL y las plataformas de Big Data. En esta sesi\u00f3n nos vamos a centrar en NoSQL.</p> <p>NoSQL aparece como una necesidad debida al creciente volumen de datos sobre usuarios, objetos y productos que las empresas tienen que almacenar, as\u00ed como la frecuencia con la que se accede a los datos. Los SGDB relacionales existentes no fueron dise\u00f1ados teniendo en cuenta la escalabilidad ni la flexibilidad necesaria por las frecuentes modificaciones que necesitan las aplicaciones modernas; tampoco aprovechan que el almacenamiento a d\u00eda de hoy es muy barato, ni el nivel de procesamiento que alcanzan las m\u00e1quinas actuales.</p> <p>La soluci\u00f3n es el despliegue de las aplicaciones y sus datos en cl\u00fasteres de servidores, distribuyendo el procesamiento en m\u00faltiples m\u00e1quinas.</p>"},{"location":"nosql/nosql/#no-solo-sql","title":"No Solo SQL","text":""},{"location":"nosql/nosql/#definicion-nosql","title":"Definici\u00f3n NoSQL","text":"<p>Si definimos NoSQL formalmente, podemos decir que se trata de un conjunto de tecnolog\u00edas que permiten el procesamiento r\u00e1pido y eficiente de conjuntos de datos dando la mayor importancia al rendimiento, la fiabilidad y la agilidad.</p> <p>Si nos basamos en el acr\u00f3nimo, el t\u00e9rmino da la sensaci\u00f3n que se refiere a cualquier almac\u00e9n de datos que no sigue un modelo relacional, los datos no son relacionales y por tanto no utilizan SQL como lenguaje de consulta. Realmente implica que el No hace referencia a not only, es decir, que los sistemas NoSQL se centran en sistemas complementarios a los SGBD relacionales, que fijan sus prioridades en la escalabilidad y la disponibilidad en contra de la atomicidad y consistencia de los datos.</p> <p>Es decir, m\u00e1s que sustitutos de los sistemas relacionales, las soluciones NoSQL se plantean como alternativas y complementarias a los sistemas gestores de bases de datos relacionales.</p> <p>ACID</p> <p>Las bases de datos relacionales cumplen las caracter\u00edsticas ACID para ofrecer transaccionalidad sobre los datos:</p> <ul> <li>Atomicidad: las transacciones implican que se realizan todas las operaciones o no se realiza ninguna.</li> <li>Consistencia: la base de datos asegura que los datos pasan de un estado v\u00e1lido o otro tambi\u00e9n.</li> <li>Isolation (Aislamiento): Una transacci\u00f3n no afecta a otras transacciones, de manera que la modificaci\u00f3n de un registro / documento no es visible por otras lecturas hasta que ha finalizado la transacci\u00f3n. Esto implica que ninguna transacci\u00f3n obtiene una versi\u00f3n intermedia de los datos.</li> <li>Durabilidad: La escritura de los datos asegura que una vez finalizada una operaci\u00f3n, los datos no se perder\u00e1n.</li> </ul> <p>Los diferentes tipos de bases de datos NoSQL existentes se pueden agrupar en cuatro categor\u00edas:</p> <ul> <li> <p>Clave-Valor: Los almacenes clave-valor son las bases de datos NoSQL m\u00e1s simples. Cada elemento de la base de datos se almacena con un nombre de atributo (o clave) junto a su valor, a modo de diccionario. Los almacenes m\u00e1s conocidos son Redis, Riak y AWS DynamoDB. Algunos almacenes, como es el caso de Redis, permiten que cada valor tenga un tipo (por ejemplo, integer) lo cual a\u00f1ade funcionalidad extra.</p> </li> <li> <p>Documentales: Cada clave se asocia a una estructura compleja que se conoce como documento. Este puede contener diferentes pares clave-valor, o pares de clave-array o incluso documentos anidados, como en un documento JSON. Los ejemplos m\u00e1s conocidos son MongoDB, CouchDB o Elastic Search.</p> </li> <li> <p>Grafos: Los almacenes de grafos se usan para almacenar informaci\u00f3n sobre redes, como pueden ser conexiones sociales. Los ejemplos m\u00e1s conocidos son Neo4j, Amazon Neptune y ArangoDB.</p> </li> <li> <p>Basados en columnas: Los almacenes basados en columnas como Hypertabla de Google, Apache Cassandra y Apache HBase est\u00e1n optimizados para consultas sobre grandes conjuntos de datos, y almacenan los datos como columnas en vez de como filas.</p> </li> </ul>"},{"location":"nosql/nosql/#caracteristicas-principales","title":"Caracter\u00edsticas principales","text":"<p>Si nos centramos en sus beneficios y los comparamos con las base de datos relacionales, las bases de datos NoSQL son m\u00e1s escalables, ofrecen un rendimiento mayor y sus modelos de datos resuelven varios problemas que no se plantearon al definir el modelo relacional:</p> <ul> <li>Grandes vol\u00famenes de datos estructurados, semi-estructurados y sin estructurar. Casi todas las implementaciones NoSQL ofrecen alg\u00fan tipo de representaci\u00f3n para datos sin esquema, lo que permite comenzar con una estructura y con el paso del tiempo, a\u00f1adir nuevos campos, ya sean sencillos o anidados a datos ya existentes.</li> <li>Sprints \u00e1giles, iteraciones r\u00e1pidas y frecuentes commits/pushes de c\u00f3digo, al emplear una sintaxis sencilla para la realizaci\u00f3n de consultas y la posibilidad de tener un modelo que vaya creciendo al mismo ritmo que el desarrollo.</li> <li>Arquitectura eficiente y escalable dise\u00f1ada para trabajar con clusters en vez de una arquitectura monol\u00edtica y costosa. Las soluciones NoSQL soportan la escalabilidad de un modo transparente para el desarrollador y ofrecen una soluci\u00f3n cloud.</li> </ul> <p>Una caracter\u00edstica adicional que comparten los sistemas NoSQL es que ofrecen un mecanismo de cach\u00e9 de datos integrado (en los sistemas relacionales se pueden configurar de manera externa), pudiendo configurar los sistemas para que los datos se mantengan en memoria y se persistan de manera peri\u00f3dica. El uso de una cach\u00e9 conlleva que la consistencia de los datos no sea completa y podamos tener una consistencia eventual.</p>"},{"location":"nosql/nosql/#esquemas-dinamicos","title":"Esquemas din\u00e1micos","text":"<p>Las bases de datos relacionales requieren definir los esquemas antes de a\u00f1adir los datos. Una base de datos SQL necesita saber de antemano los datos que vamos a almacenar; por ejemplo, si nos centramos en los datos de un cliente, ser\u00edan el nombre, apellidos, n\u00famero de tel\u00e9fono, etc\u2026\u200b</p> <p>Esto casa bastante mal con los enfoques de desarrollo \u00e1gil, ya que cada vez que a\u00f1adimos nuevas funcionalidades, el esquema de la base de datos suele cambiar. De modo que si a mitad de desarrollo decidimos almacenar los productos favoritos de un cliente del cual guard\u00e1bamos su direcci\u00f3n y n\u00fameros de tel\u00e9fono, tendr\u00edamos que a\u00f1adir una nueva columna a la base de datos y migrar la base de datos entera a un nuevo esquema.</p> <p>Si la base de datos es grande, conlleva un proceso lento que implica parar el sistema durante un tiempo considerable. Si frecuentemente cambiamos los datos que la aplicaci\u00f3n almacena (al usar un desarrollo iterativo), tambi\u00e9n tendremos per\u00edodos frecuentes de inactividad del sistema, a no ser que utilicemos un despliegue azul/verde y tengamos redundancia de nuestro sistema de almacenamiento. As\u00ed pues, no hay un modo efectivo mediante una base de datos relacional de almacenar los datos que est\u00e1n desestructurados o que no se conocen de antemano.</p> <p>Las bases de datos NoSQL se construyen para permitir la inserci\u00f3n de datos sin un esquema predefinido. Esto facilita la modificaci\u00f3n de la aplicaci\u00f3n en tiempo real, sin preocuparse por interrupciones de servicio. Aunque no tengamos un esquema al guardar la informaci\u00f3n, s\u00ed que podemos definir esquemas de lectura (schema-on-read) para comprobar que la informaci\u00f3n almacenada tiene el formato que espera cargar cada aplicaci\u00f3n.</p> <p>De este modo se consigue un desarrollo m\u00e1s r\u00e1pido, integraci\u00f3n de c\u00f3digo m\u00e1s robusto y menos tiempo empleado en la administraci\u00f3n de la base de datos.</p> <p>Aunque lo veremos en profundidad en las siguientes sesiones, los modelos de datos NoSQL priman la redundancia de los datos, denormalizando los datos para evitar el uso de joins. Por ello, es importante que la definici\u00f3n de los esquemas sea flexible para poder a\u00f1adir campos conforme la aplicaci\u00f3n evolucione.</p>"},{"location":"nosql/nosql/#particionado-sharding","title":"Particionado (Sharding)","text":"<p>Dado el modo en el que se estructuran las bases de datos relacionales, normalmente escalan verticalmente, un \u00fanico servidor cada vez m\u00e1s potente (m\u00e1s RAM, mejor CPU y almacenamiento), que almacena toda la base de datos para asegurar la disponibilidad continua de los datos. Esto se traduce en costes que se incrementan r\u00e1pidamente, con un l\u00edmites definidos por el propio hardware, y en un peque\u00f1o n\u00famero de puntos cr\u00edticos de fallo dentro de la infraestructura de datos.</p> <p>La soluci\u00f3n es escalar horizontalmente, a\u00f1adiendo nuevos servidores en vez de concentrarse en incrementar la capacidad de un \u00fanico servidor, lo que permite tratar con conjuntos de datos m\u00e1s grandes de lo que ser\u00eda capaz cualquier m\u00e1quina por s\u00ed sola. Este escalado horizontal se conoce como Sharding o Particionado.</p> <p>El particionado no es \u00fanico de las bases de datos NoSQL. Las bases de datos relacionales tambi\u00e9n lo soportan. Si en un sistema relacional queremos particionar los datos, podemos distinguir entre particionado:</p> <ul> <li>Horizontal: diferentes filas en diferentes particiones.</li> <li>Vertical: diferentes columnas en particiones distintas.</li> </ul> Particionado de datos - digitalocean.com <p>En el caso de las bases de datos NoSQL, el particionado depende del modelo de la base de datos:</p> <ul> <li>Los almacenes clave-valor y las bases de datos documentales normalmente se particionan horizontalmente.</li> <li>Las bases de datos basados en columnas se pueden particionar horizontal o verticalmente. Escalar horizontalmente una base de datos relacional entre muchas instancias de servidores se puede conseguir pero normalmente conlleva el uso de SANs (Storage Area Networks) y otras triqui\u00f1uelas para hacer que el hardware act\u00fae como un \u00fanico servidor.</li> </ul> <p>Como los sistemas SQL no ofrecen esta prestaci\u00f3n de forma nativa, los equipos de desarrollo se las tienen que ingeniar para conseguir desplegar m\u00faltiples bases de datos relacionales en varias m\u00e1quinas. Para ello:</p> <ul> <li>Los datos se almacenan en cada instancia de base de datos de manera aut\u00f3noma</li> <li>El c\u00f3digo de aplicaci\u00f3n se desarrolla para distribuir los datos y las consultas y agregar los resultados de los datos a trav\u00e9s de todas las instancias de bases de datos</li> <li>Se debe desarrollar c\u00f3digo adicional para gestionar los fallos sobre los recursos, para realizar joins entre diferentes bases de datos, balancear los datos y/o replicarlos, etc\u2026\u200b Adem\u00e1s, muchos beneficios de las bases de datos como la integridad transaccional se ven comprometidos o incluso eliminados al emplear un escalado horizontal.</li> </ul>"},{"location":"nosql/nosql/#autosharding","title":"Auto\u2011sharding","text":"<p>Por contra, las bases de datos NoSQL normalmente soportan auto-sharding, lo que implica que de manera nativa y autom\u00e1ticamente se dividen los datos entre un n\u00famero arbitrario de servidores, sin que la aplicaci\u00f3n sea consciente de la composici\u00f3n del pool de servidores. Los datos y las consultas se balancean entre los servidores.</p> <p>El particionado se realiza mediante un m\u00e9todo consistente, como puede ser:</p> <ul> <li>Por rangos de su id: por ejemplo \"los usuarios del 1 al mill\u00f3n est\u00e1n en la partici\u00f3n 1\" o \"los usuarios cuyo nombre va de la A a la L\" en una partici\u00f3n, en otra de la M a la Q, y de la R a la Z en la tercera.</li> </ul> Particionado por rango - digitalocean.com <ul> <li>Por listas: dividiendo los datos por la categor\u00eda del dato, es decir, en el caso de datos sobre libros, las novelas en una partici\u00f3n, las recetas de cocina en otra, etc..</li> <li>Mediante una funci\u00f3n hash, la cual devuelve un valor para un elemento que determine a qu\u00e9 partici\u00f3n pertenece.</li> </ul> Particionado por hash - digitalocean.com"},{"location":"nosql/nosql/#cuando-particionar","title":"Cu\u00e1ndo particionar","text":"<p>El motivo para particionar los datos se debe a:</p> <ul> <li>limitaciones de almacenamiento: los datos no caben en un \u00fanico servidor, tanto a nivel de disco como de memoria RAM.</li> <li>rendimiento: al balancear la carga entre particiones las escrituras ser\u00e1n m\u00e1s r\u00e1pidas que al centrarlas en un \u00fanico servidor.</li> <li>disponibilidad: si un servidor esta ocupado, otro servidor puede devolver los datos. La carga de los servidores se reduce.</li> </ul> <p>No particionaremos los datos cuando la cantidad sea peque\u00f1a, ya que el hecho de distribuir los datos conlleva unos costes que pueden no compensar con un volumen de datos insuficiente. Tampoco esperaremos a particionar cuando tengamos much\u00edsimos datos, ya que el proceso de particionado puede provocar sobrecarga del sistema.</p> <p>La nube facilita de manera considerable este escalado, mediante proveedores como AWS o Azure los cuales ofrecen virtualmente una capacidad ilimitada bajo demanda, y despreocup\u00e1ndose de todas las tareas necesarias para la administraci\u00f3n de la base de datos.</p> <p>Los desarrolladores ya no necesitamos construir plataformas complejas para nuestras aplicaciones, de modo que nos podemos centrar en escribir c\u00f3digo de aplicaci\u00f3n. Una granja de servidores con commodity hardware puede ofrecer el mismo procesamiento y capacidad de almacenamiento que un \u00fanico servidor de alto rendimiento por mucho menos coste.</p>"},{"location":"nosql/nosql/#replicacion","title":"Replicaci\u00f3n","text":"<p>La replicaci\u00f3n mantiene copias id\u00e9nticas de los datos en m\u00faltiples servidores, lo que facilita que las aplicaciones siempre funcionen y los datos se mantengan seguros, incluso si alguno de los servidores sufre alg\u00fan problema.</p> <p>La mayor\u00eda de las bases de datos NoSQL tambi\u00e9n soportan la replicaci\u00f3n autom\u00e1tica, lo que implica una alta disponibilidad y recuperaci\u00f3n frente a desastres sin la necesidad de aplicaciones de terceros encargadas de ello. Desde el punto de vista del desarrollador, el entorno de almacenamiento es virtual y ajeno al c\u00f3digo de aplicaci\u00f3n.</p> <p>Existen dos formas de realizar la replicaci\u00f3n:</p>"},{"location":"nosql/nosql/#maestro-esclavo-primario-secundario","title":"Maestro-esclavo / Primario-secundario","text":"<p>Todas las escrituras se realizan en el nodo principal y despu\u00e9s se replican a los nodos secundarios. El nodo primario es un SPOF (single point of failure).</p> Replicaci\u00f3n Primario-secundario"},{"location":"nosql/nosql/#par-a-par-peer-to-peer","title":"Par-a-par (peer-to-peer)","text":"<p>Todos los nodos tienen el mismo nivel jer\u00e1rquico, de manera que todos admiten escrituras. Al poder haber escrituras simult\u00e1neas sobre el mismo datos en diferentes nodos, pueden darse inconsistencia en los datos.</p> Replicaci\u00f3n Par-a-par <p>La replicaci\u00f3n de los datos se utiliza para alcanzar:</p> <ul> <li>escalabilidad, incrementando el rendimiento al poder distribuir las consultas en diferentes nodos, y mejorar la redundancia al permitir que cada nodo tenga una copia de los datos.</li> <li>disponibilidad, ofreciendo tolerancia a fallos de hardware o corrupci\u00f3n de la base de datos. Al replicar los datos vamos a poder tener una copia de la base de datos, dar soporte a un servidor de datos agregados, o tener nodos a modo de copias de seguridad que pueden tomar el control en caso de fallo.</li> <li>aislamiento (la i en ACID - isolation), entendido como la propiedad que define cuando y c\u00f3mo al realizar cambios en un nodo se propagan al resto de nodos. Si replicamos los datos podemos crear copias sincronizadas para separar procesos de la base de datos de producci\u00f3n, pudiendo ejecutar informes, anal\u00edtica de datos o copias de seguridad en nodos secundarios de modo que no tenga un impacto negativo en el nodo principal, as\u00ed como ofrecer un sistema sencillo para separar el entorno de producci\u00f3n del de preproducci\u00f3n.</li> </ul> <p>Replicaci\u00f3n vs particionado</p> <p>No hay que confundir la replicaci\u00f3n (copia de los datos en varias m\u00e1quinas) con el particionado (cada m\u00e1quina tiene un subconjunto de los datos). El entorno m\u00e1s seguro y con mejor rendimiento es aquel que tiene los datos particionados y replicados (cada m\u00e1quina que tiene un subconjunto de los datos est\u00e1 replicada en 2 o m\u00e1s).</p> Replicaci\u00f3n y particionado - codingexplained.com <p></p>"},{"location":"nosql/nosql/#implantando-nosql","title":"Implantando NoSQL","text":"<p>Normalmente, las empresas empezar\u00e1n con una prueba de baja escalabilidad de una base de datos NoSQL, de modo que les permita comprender la tecnolog\u00eda asumiendo muy poco riesgo. La mayor\u00eda de las bases de datos NoSQL tambi\u00e9n son open-source, y por tanto se pueden probar sin ning\u00fan coste extra. Al tener unos ciclos de desarrollo m\u00e1s r\u00e1pidos, las empresas pueden innovar con mayor velocidad y mejorar la experiencia de sus cliente a un menor coste.</p> <p>Consideraciones</p> <ul> <li>\u00bfCu\u00e1l es el crecimiento previsto de nuestra aplicaci\u00f3n en un futuro pr\u00f3ximo, por ejemplo, el n\u00famero de usuarios, y c\u00f3mo crecer\u00e1 en 3 meses, 6 meses o un a\u00f1o?</li> <li>Para soportar el crecimiento de la base de usuarios, \u00bfqu\u00e9 funciones de nuestra aplicaci\u00f3n requerir\u00e1n m\u00e1s almacenamiento de datos y pueden escalarse?</li> <li>\u00bfC\u00f3mo podemos distribuir l\u00f3gica y f\u00edsicamente nuestros datos? Por ejemplo, si nuestra aplicaci\u00f3n requiere soporte geogr\u00e1fico para dar servicio a varias ciudades, \u00bfpodemos distribuir o separar algunos datos en funci\u00f3n de las ciudades?</li> <li>\u00bfQu\u00e9 impacto tendr\u00eda en la empresa una ca\u00edda de la base de datos? Es decir \u00bfC\u00f3mo de importante es la alta disponibilidad de nuestra base de datos?</li> <li>\u00bfCu\u00e1l es el ratio entre las operaciones de lectura frente a las de escritura? \u00bfCu\u00e1l es su pico en horas punta? \u00bfQu\u00e9 payload se espera por operaci\u00f3n? \u00bfCu\u00e1nta CPU se necesita por operaci\u00f3n?</li> <li>\u00bfLa aplicaci\u00f3n requiere un modelo de datos fijo o flexible, el cual permita cambios en el futuro? Y si necesita cambiar el esquema de los modelos de datos existentes, \u00bfcu\u00e1l ser\u00e1 el impacto en t\u00e9rminos de parada de mantenimiento, migraciones necesarias, etc...?</li> <li>\u00bfPodemos reducir el tr\u00e1fico de nuestra aplicaci\u00f3n hacia las bases de datos y mejorar el rendimiento?.</li> </ul> <p>Planteadas estas preguntas, claramente elegir la base de datos correcta para nuestros proyectos es un tema importante. Se deben considerar las diferentes alternativas a las infraestructuras legacy teniendo en cuenta varios factores:</p> <ul> <li>La escalabilidad o el rendimiento m\u00e1s all\u00e1 de las capacidades del sistema existente.</li> <li>Identificar alternativas viables respecto al software propietario.</li> <li>Incrementar la velocidad y agilidad del proceso de desarrollo.</li> </ul> <p>As\u00ed pues, al elegir un base de datos hemos de tener en cuenta las siguientes dimensiones:</p> <ul> <li>Modelo de datos: A elegir entre un modelo documental, basado en columnas, de grafos o mediante clave-valor.</li> <li>Modelo de consultas: Dependiendo de la aplicaci\u00f3n, puede ser aceptable un modelo de consultas que s\u00f3lo accede a los registros por su clave primaria. En cambio, otras aplicaciones pueden necesitar consultar por diferentes valores de cada registro. Adem\u00e1s, si la aplicaci\u00f3n necesita modificar los registros, la base de datos necesita consultar los datos por un \u00edndice secundario.</li> <li>Modelo de consistencia: Los sistemas NoSQL normalmente mantienen m\u00faltiples copias de los datos para ofrecer disponibilidad y escalabilidad al sistema, lo que define la consistencia del mismo. Los sistemas NoSQL tienden a ser consistentes o eventualmente consistentes.</li> <li>APIs: No existe un est\u00e1ndar para interactuar con los sistemas NoSQL. Cada sistema presenta diferentes dise\u00f1os y capacidades para los equipos de desarrollo. La madurez de un API puede suponer una inversi\u00f3n en tiempo y dinero a la hora de desarrollar y mantener el sistema NoSQL.</li> <li>Soporte comercial y de la comunidad: Los usuarios deben considerar la salud de la compa\u00f1\u00eda o de los proyectos al evaluar una base de datos. El producto debe evolucionar y mantenerse para introducir nuevas prestaciones y corregir fallos. Una base de datos con una comunidad fuerte de usuarios:<ul> <li>Permite encontrar y contratar desarrolladores con destrezas en el producto</li> <li>Facilita encontrar informaci\u00f3n, documentaci\u00f3n y ejemplos de c\u00f3digo.</li> <li>Ayuda a las empresas a retener el talento.</li> <li>Favorece que otras empresas de software integren sus productos y participen en el ecosistema de la base de datos.</li> </ul> </li> </ul>"},{"location":"nosql/nosql/#casos-de-uso","title":"Casos de uso","text":"<p>Una vez conocemos los diferentes sistemas y qu\u00e9 elementos puede hacer que nos decidamos por una soluci\u00f3n u otra, conviene repasar los casos de uso m\u00e1s comunes:</p> <ul> <li>Si vamos a crear una aplicaci\u00f3n web cuyo campos sean personalizables, usaremos una soluci\u00f3n documental.</li> <li>Como una capa de cach\u00e9, mediante un almac\u00e9n clave-valor.</li> <li>Para almacenar archivos binarios sin preocuparse de la gesti\u00f3n de permisos del sistema de archivos, y poder realizar consultas sobre sus metadatos, ya sea mediante una soluci\u00f3n documental o un almac\u00e9n clave-valor.</li> <li>Para almacenar un enorme volumen de datos, donde la consistencia no es lo m\u00e1s importante, pero si la disponibilidad y su capacidad de ser distribuida, mediante una soluci\u00f3n documental o basada en columnas.</li> </ul>"},{"location":"nosql/nosql/#limitaciones","title":"Limitaciones","text":"<p>Una vez que hemos conocido todas las bondades, es conviente citar las limitaciones asociadas a las soluciones NoSQL:</p> <ul> <li>Falta de est\u00e1ndar: Cada base de datos NoSQL surgi\u00f3 de la necesidad de diferentes casos de uso, y al basarse en c\u00f3digo abierto, ninguna base de datos NoSQL es igual a otra y no hay directrices est\u00e1ndar para su uso.</li> <li>Riesgos del c\u00f3digo abierto: Aunque muchas de las soluciones NoSQL han derivado en productos comerciales, puede que algunas de ellas no se mantengan de forma continua y que no haya soporte si nos encontramos con alg\u00fan problema. Es por ello, que es conveniente comprobar el soporte de la comunidad y de si hay una versi\u00f3n enterprise que podamos contratar en caso de necesidad.</li> <li>Falta de interfaces gr\u00e1ficos para acceder a las bases de datos NoSQL: S\u00f3lo unas pocas soluciones NoSQL soportan una forma f\u00e1cil de interactuar con los datos.</li> <li>Perfiles escasos: Al tratarse de una nueva tecnolog\u00eda, encontrar expertos NoSQL a veces es dif\u00edcil y costoso.</li> </ul>"},{"location":"nosql/nosql/#actividades-propuestas","title":"\ud83d\udcdd Actividades propuestas","text":"<p>Actividades</p> <ol> <li>\u00bfQu\u00e9 significa el prefijo \u201cNo\u201d en NoSQL?  </li> <li>\u00bfPuede un sistema soportar replicaci\u00f3n y particionado simult\u00e1neamente?  </li> </ol>"}]}